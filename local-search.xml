<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>观察者模式</title>
    <link href="/2024/06/29/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/06/29/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>观察者模式是一种一对多的关系，当一个对象状态发生改变时，所有依赖于它的对象都得到通知并完成更新</p><ul><li>被观察者（Observerable）：目标对象，状态发生变化时，通知所有的观察者</li><li>观察者（Observer）：接收被观察者状态变化通知</li></ul><p>例如异步通知场景</p><ol><li>定义被观察者</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observable</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Observer&gt; observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> state;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span>&#123;<br>        notifyAllObservers(state);<br>    &#125;<br><br>    <span class="hljs-comment">// 添加观察者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserve</span><span class="hljs-params">(Observer observer)</span>&#123;<br>        observers.add(observer);<br>    &#125;<br>    <span class="hljs-comment">// 移除观察者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserve</span><span class="hljs-params">(Observer observer)</span>&#123;<br>        observers.remove(observer);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAllObservers</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span>&#123;<br>        <span class="hljs-keyword">if</span> (state != <span class="hljs-number">1</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;不是通知状态&quot;</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Observer observer : observers) &#123;<br>            observer.doEvent();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>观察者接口以及实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 观察者方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doEvent</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doEvent</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;发邮件&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MobileObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doEvent</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>枚举实现责任链</title>
    <link href="/2024/06/26/%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E8%B4%A3%E4%BB%BB%E9%93%BE/"/>
    <url>/2024/06/26/%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E8%B4%A3%E4%BB%BB%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>责任链允许请求沿着处理者链进行处理，类似于拦截器</p><p>责任链由三部分组成</p><ul><li>抽象处理者（Handler）：定义一个处理请求的抽象类，包含处理方法和一个 next 指针</li><li>具体处理者：实现抽象处理者方法</li><li>客户端</li></ul><p>抽象处理者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayHandler</span> &#123;<br>    <span class="hljs-keyword">protected</span> GatewayHandler next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNext</span><span class="hljs-params">(GatewayHandler next)</span>&#123;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">handler</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiLimitGatewayHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GatewayHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(ApiLimitGatewayHandler.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">handler</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;Api 限流网关处理器执行中...&quot;</span>);<br>        <span class="hljs-comment">// ... 这里判断是否满足这个责任链</span><br>        <span class="hljs-comment">// 如果满足，看是否有下一个责任链，</span><br>        <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> next.handler();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlackListGatewayHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GatewayHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(BlackListGatewayHandler.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">handler</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;黑名单处理器执行中...&quot;</span>);<br>        <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> next.handler();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SessionGatewayHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GatewayHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(SessionGatewayHandler.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">handler</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;Session 处理器执行中...&quot;</span>);<br>        <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> next.handler();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来用枚举进行责任链的配置</p><p>目录结构：</p><p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240630130532.png"></p><ol><li>定义一个实体类，存放责任链的实体信息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayEntity</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String conference;  <span class="hljs-comment">// 全限定类名</span><br>    <span class="hljs-keyword">private</span> Integer handlerId; <br>    <span class="hljs-keyword">private</span> Integer preHandlerId;<br>    <span class="hljs-keyword">private</span> Integer nextHandlerId;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>定义一个枚举，里面存储 <code>GatewayEntity</code> （枚举本质上也是一个类，里面的枚举对象是用一个数组存储的）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">GatewayEnum</span> &#123;<br>    API_HANDLER(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GatewayEntity</span>(<span class="hljs-string">&quot;API 限流&quot;</span>, <span class="hljs-string">&quot;com.dong.demo.design.chain.impl.ApiLimitGatewayHandler&quot;</span>,<br>            <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>)),<br>    BLACKLIST_HANDLER(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GatewayEntity</span>(<span class="hljs-string">&quot;黑名単限流&quot;</span>, <span class="hljs-string">&quot;com.dong.demo.design.chain.impl.BlackListGatewayHandler&quot;</span>,<br>            <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)),<br>    SESSION_HANDLER(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GatewayEntity</span>(<span class="hljs-string">&quot;用户会话限流&quot;</span>, <span class="hljs-string">&quot;com.dong.demo.design.chain.impl.SessionGatewayHandler&quot;</span>,<br>            <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>));<br><br>    <span class="hljs-keyword">private</span> GatewayEntity gatewayEntity;<br><br>    GatewayEnum(GatewayEntity gatewayEntity)&#123;<br>        <span class="hljs-built_in">this</span>.gatewayEntity = gatewayEntity;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> GatewayEntity <span class="hljs-title function_">getGatewayEntity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> gatewayEntity;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>一个接口，获取第一个 <code>GatewayEntity</code> 和指定的 <code>GatewayEntity</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GatewayEntityService</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据 handlerId 获取配置项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handlerId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    GatewayEntity <span class="hljs-title function_">getGatewayEntity</span><span class="hljs-params">(Integer handlerId)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取第一个 handler</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    GatewayEntity <span class="hljs-title function_">getFirstGatewayEntity</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayEntityServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GatewayService</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GatewayEntity&gt; gatewayEntityMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        GatewayEnum[] values = GatewayEnum.values();<br>        <span class="hljs-keyword">for</span> (GatewayEnum value : values) &#123;<br>            <span class="hljs-type">GatewayEntity</span> <span class="hljs-variable">gatewayEntity</span> <span class="hljs-operator">=</span> value.getGatewayEntity();<br>            gatewayEntityMap.put(gatewayEntity.getHandlerId(), gatewayEntity);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> GatewayEntity <span class="hljs-title function_">getGatewayEntity</span><span class="hljs-params">(Integer handlerId)</span> &#123;<br>        <span class="hljs-keyword">return</span> gatewayEntityMap.get(handlerId);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> GatewayEntity <span class="hljs-title function_">getFirstGatewayEntity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, GatewayEntity&gt; entity : gatewayEntityMap.entrySet()) &#123;<br>            <span class="hljs-type">GatewayEntity</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entity.getValue();<br>            <span class="hljs-keyword">if</span> (value.getPreHandlerId() == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>一个工厂类，获取第一个 <code>handler</code> 并把其他的 <code>handler</code> 串联起来</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayHandlerEnumFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">GatewayEntityService</span> <span class="hljs-variable">gatewayService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GatewayEntityServiceImpl</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取第一个 handler</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GatewayHandler <span class="hljs-title function_">getFirstGatewayHandler</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">GatewayEntity</span> <span class="hljs-variable">firstGatewayEntity</span> <span class="hljs-operator">=</span> gatewayService.getFirstGatewayEntity();<br>        <span class="hljs-type">GatewayHandler</span> <span class="hljs-variable">firstGatewayHandler</span> <span class="hljs-operator">=</span> newGatewayHandler(firstGatewayEntity);<br>        <span class="hljs-keyword">if</span> (firstGatewayHandler == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">GatewayEntity</span> <span class="hljs-variable">curGatewayEntity</span> <span class="hljs-operator">=</span> firstGatewayEntity;<br>        <span class="hljs-type">GatewayHandler</span> <span class="hljs-variable">curGatewayHandler</span> <span class="hljs-operator">=</span> firstGatewayHandler;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">nextHandlerId</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> ((nextHandlerId = curGatewayEntity.getNextHandlerId()) != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">GatewayEntity</span> <span class="hljs-variable">gatewayEntity</span> <span class="hljs-operator">=</span> gatewayService.getGatewayEntity(nextHandlerId);<br>            <span class="hljs-type">GatewayHandler</span> <span class="hljs-variable">gatewayHandler</span> <span class="hljs-operator">=</span> newGatewayHandler(gatewayEntity);<br>            curGatewayHandler.setNext(gatewayHandler);<br>            curGatewayEntity = gatewayEntity;<br>            curGatewayHandler = gatewayHandler;<br>        &#125;<br>        <span class="hljs-keyword">return</span> firstGatewayHandler;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反射实例化具体的处理者</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> gatewayEntity</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> GatewayHandler <span class="hljs-title function_">newGatewayHandler</span><span class="hljs-params">(GatewayEntity gatewayEntity)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> gatewayEntity.getConference();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; clazz = Class.forName(className);<br>            <span class="hljs-keyword">return</span> (GatewayHandler) clazz.newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>一个客户端进行测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GatewayHandler</span> <span class="hljs-variable">firstGatewayHandler</span> <span class="hljs-operator">=</span> GatewayHandlerEnumFactory.getFirstGatewayHandler();<br>        firstGatewayHandler.handler();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模版方法模式</title>
    <link href="/2024/06/25/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/06/25/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>定义操作中的骨架流程，将一些步骤延迟加载到子类中，使子类可以不改变结构即可重新定义该流程的特定步骤</p><ol><li>一个抽象类，定义骨架流程</li></ol><p>例如一个请求经过流程分为如下步骤</p><ul><li>解析请求头</li><li>封装数据</li><li>返回请求体</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractRequestService</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolveHead</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolve</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolveBody</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模版方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolveRequest</span><span class="hljs-params">()</span>&#123;<br>        resolveHead();<br>        resolve();<br>        resolveBody();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>实现类实现父类中的 <code>abstract</code> 方法，父类引用指向子类对象</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/2024/06/24/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/06/24/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>有多个 <code>if...else</code> 等条件分支，并且每个条件分支，可以封装起来替换的，可以使用策略模式来优化</p><ol><li>一个接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IFileStrategy</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 输入哪种文件类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    FileTypeEnum <span class="hljs-title function_">getFileType</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 具体解析方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> param</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolve</span><span class="hljs-params">(Object param)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>一个枚举，及实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">FileTypeEnum</span> &#123;<br>    A,<br>    B,<br>    C;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AFileResolve</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFileStrategy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(AFileResolve.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileTypeEnum <span class="hljs-title function_">getFileType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> FileTypeEnum.A;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolve</span><span class="hljs-params">(Object param)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;A 类型解析文件，参数：&#123;&#125;&quot;</span>, param);<br>        <span class="hljs-comment">// A 类型解析</span><br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BFileResolve</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFileStrategy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(BFileResolve.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileTypeEnum <span class="hljs-title function_">getFileType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> FileTypeEnum.B;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolve</span><span class="hljs-params">(Object param)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;B 类型解析文件，参数：&#123;&#125;&quot;</span>, param);<br>        <span class="hljs-comment">// B 类型解析</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>用 <code>ApplicationContextAware</code> 接口，把策略初始化到 map 里面</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyUseService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;FileTypeEnum, IFileStrategy&gt; iFileStrategyMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolveFile</span><span class="hljs-params">(FileTypeEnum fileTypeEnum, Object param)</span>&#123;<br>        <span class="hljs-type">IFileStrategy</span> <span class="hljs-variable">iFileStrategy</span> <span class="hljs-operator">=</span> iFileStrategyMap.get(fileTypeEnum);<br>        <span class="hljs-keyword">if</span> (iFileStrategy != <span class="hljs-literal">null</span>) &#123;<br>            iFileStrategy.resolve(param);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        Map&lt;String, IFileStrategy&gt; tempMap = applicationContext.getBeansOfType(IFileStrategy.class);<br>        tempMap.values().forEach(strategyService -&gt; iFileStrategyMap.put(strategyService.getFileType(), strategyService));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列幂等方案</title>
    <link href="/2024/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B9%82%E7%AD%89%E6%96%B9%E6%A1%88/"/>
    <url>/2024/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B9%82%E7%AD%89%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>如果一个消息队列对某个消息发送了两次，导致入库两条相同的数据，如何避免</p></blockquote><p>也即如何保证幂等性，接下来讨论的前提是全局唯一 ID</p><h1 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h1><p>最简单的方案，先查 ID 在数据库里有没有，如果没有则入库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">vo = select(id);<br><span class="hljs-keyword">if</span> (vo == <span class="hljs-literal">null</span>)&#123;<br>  save(信息)<br>&#125;<br></code></pre></td></tr></table></figure><p>先查询，再判断，再保存，在多线程的情况下，还是拦不住</p><p>可以在数据表中加<strong>唯一索引</strong>方案解决，在数据库层面抛异常，来保证幂等</p><p>如果要保证少抛异常，看接下来的方案</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>为了保证在并发条件下，也只有一个请求到数据库，可以用锁的方式</p><p>以 id 为 key 加锁，如果加锁成功，则放行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">flag = addRedisLock(id, 过期时间);<br><span class="hljs-keyword">if</span> (flag)&#123;<br>  save(信息)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果此时 Redis 锁成功了，但是还没 save，Redis 重启了，理论上是可以重试的，但是由于 Redis 锁的存在，导致不会走到 save 的逻辑</p><ul><li><p>人工介入，删除 Redis 对应的 key</p></li><li><p>由于设置了过期时间，等过期时间过了之后的请求理论上还是可以拿到锁，所以加一个重试机制</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">flag = addRedisLock(id, 过期时间, 获取不到则等待);<br><span class="hljs-keyword">if</span> (flag)&#123;<br>  save(信息)<br>&#125;<br></code></pre></td></tr></table></figure><p>由于有锁等待的逻辑，如果两个请求过来，还是有可能都放到 Redis 里，save 方法还是会走两遍，所以还需要加一个查询数据库的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">flag = addRedisLock(id, 过期时间, 获取不到则等待);<br><span class="hljs-keyword">if</span> (flag)&#123;<br>  vo = select(id);<br>  <span class="hljs-keyword">if</span> (vo == <span class="hljs-literal">null</span>)&#123;<br>    save(信息);<br>  &#125;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 等待结束后还是未获取到锁，发送预警</span><br>  monitor(预警信息);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>最开始加唯一索引需求是根据业务表来做的，如果出现问题就让它抛出主键异常</p><p>如何设计一个通用技术组件，不依赖于业务场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">vo = select <span class="hljs-keyword">for</span> <span class="hljs-title function_">update</span><span class="hljs-params">(id)</span>;<br><span class="hljs-keyword">if</span> (vo == <span class="hljs-literal">null</span>)&#123;<br>  save(message);<br>&#125;<br></code></pre></td></tr></table></figure><p>也是加锁，但是这样性能就太差了</p><p>设计一个 <code>消息消费记录表</code> 专门为了解决幂等问题而存在的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (保存数据到消息消费记录表)&#123; <span class="hljs-comment">// 出现主键冲突就返回 false</span><br>  save(message);<br>&#125;<br></code></pre></td></tr></table></figure><p>先判断，再保存，非原子性，多线程情况下也不行</p><p>加入事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">begin transaction;<br><span class="hljs-keyword">if</span> (保存数据到消息消费记录表)&#123; <span class="hljs-comment">// 出现主键冲突就返回 false</span><br>  save(message);<br>&#125;<br>end transaction;<br></code></pre></td></tr></table></figure><p>一般来说，能不用事务就不使用事务，通过最终一致性来保证数据完整性</p><p>所以可以在 <code>消费记录表</code> 中加一个状态字段，状态有两个取值：消费中，消费完成</p><p>同时把唯一索引改成 <code>消息唯一标识 + 状态</code></p><p>首先 MQ 发起请求，数据往消费记录表中插入，状态是“消费中”<br>如果插入成功，说明第一次消费，进入到业务逻辑中</p><ul><li>如果业务逻辑执行成功，则更新消费记录表对应数据为“消费完成”</li><li>如果业务执行失败，删除消费记录表对应的数据，把消息扔回 MQ，等待下次重试<br>如果插入失败，说明重复消费，直接丢弃</li></ul><p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240630134342.png"></p><p>其实插入失败这里还应该判断状态是否是消费成功的，如果是消费成功的，才应该丢弃</p><p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240630134704.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redission tryLock</title>
    <link href="/2024/05/28/Redission-tryLock/"/>
    <url>/2024/05/28/Redission-tryLock/</url>
    
    <content type="html"><![CDATA[<h1 id="Redisson-的-tryLock"><a href="#Redisson-的-tryLock" class="headerlink" title="Redisson 的 tryLock"></a>Redisson 的 tryLock</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit)</span><br></code></pre></td></tr></table></figure><p>在 waitTime 时间范围内尝试获取锁, 如果获取到锁, 设置过期时间 leaseTime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonLock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RedissonBaseLock</span> &#123;<br>    <span class="hljs-comment">// 在waitTime时间范围内尝试获取锁，如果获取到锁，则设置锁过期时间leaseTime</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> unit.toMillis(waitTime);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-comment">// 第一步：尝试获取锁</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">ttl</span> <span class="hljs-operator">=</span> tryAcquire(waitTime, leaseTime, unit, threadId);<br>        <span class="hljs-comment">// ttl为空说明获取到了锁</span><br>        <span class="hljs-keyword">if</span> (ttl == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 判断尝试获取锁是否超过waitTime</span><br>        time -= System.currentTimeMillis() - current;<br>        <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>) &#123;<br>            acquireFailed(waitTime, unit, threadId);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 第二步：订阅解锁消息通知</span><br>        current = System.currentTimeMillis();<br>        <span class="hljs-comment">// 订阅锁释放</span><br>        RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);<br>        <span class="hljs-comment">// 等待锁释放消息，等待时间超过waitTime，获取锁失败</span><br>        <span class="hljs-keyword">if</span> (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) &#123;<br>            <span class="hljs-comment">// 如果订阅解锁Future在执行中，等任务执行完后取消订阅锁释放</span><br>            <span class="hljs-keyword">if</span> (!subscribeFuture.cancel(<span class="hljs-literal">false</span>)) &#123;<br>                subscribeFuture.onComplete((res, e) -&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">// 取消订阅解锁通知</span><br>                        unsubscribe(subscribeFuture, threadId);<br>                    &#125;<br>                &#125;);<br>            &#125;<br>            acquireFailed(waitTime, unit, threadId);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 判断尝试获取锁是否超过waitTime</span><br>            time -= System.currentTimeMillis() - current;<br>            <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>) &#123;<br>                acquireFailed(waitTime, unit, threadId);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        <br>            <span class="hljs-comment">// 第三步：自旋尝试获取锁</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>                <span class="hljs-comment">// 1、尝试获取锁(下文会详细解析此方法)</span><br>                ttl = tryAcquire(waitTime, leaseTime, unit, threadId);<br>                <span class="hljs-comment">// ttl为空说明获取到了锁</span><br>                <span class="hljs-keyword">if</span> (ttl == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 判断尝试获取锁是否超过waitTime</span><br>                time -= System.currentTimeMillis() - currentTime;<br>                <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>) &#123;<br>                    acquireFailed(waitTime, unit, threadId);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 等待锁释放（信号量控制）</span><br>                currentTime = System.currentTimeMillis();<br>                <span class="hljs-keyword">if</span> (ttl &gt;= <span class="hljs-number">0</span> &amp;&amp; ttl &lt; time) &#123;<br>                    <span class="hljs-comment">// 尝试获取信号量</span><br>                    subscribeFuture.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    subscribeFuture.getNow().getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);<br>                &#125;<br><br>                <span class="hljs-comment">// 判断尝试获取锁是否超过waitTime</span><br>                time -= System.currentTimeMillis() - currentTime;<br>                <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>) &#123;<br>                    acquireFailed(waitTime, unit, threadId);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 第四步：取消解锁订阅</span><br>            unsubscribe(subscribeFuture, threadId);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要分为以下四步</p><ul><li>tryAcquire 尝试获取锁, 获取到返回 true</li><li>获取不到说明锁被占用了, 订阅结果消息通知</li><li>收到消息解锁通知, 自旋获取锁, 直到 waitTime 获取锁失败</li><li>不论是否获取锁成功, 取消解锁消息订阅</li></ul><p>tryAcquire 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Long <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId)</span> &#123;<br>    <span class="hljs-keyword">return</span> get(tryAcquireAsync(waitTime, leaseTime, unit, threadId));<br>&#125;<br><br><span class="hljs-keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="hljs-title function_">tryAcquireAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId)</span> &#123;<br>    RFuture&lt;Long&gt; ttlRemainingFuture;<br>    <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1</span>) &#123;<br>        ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 这里需要注意的是leaseTime == -1，会触发redisson看门狗机制</span><br>        ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,<br>                TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);<br>    &#125;<br>    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取锁成功</span><br>        <span class="hljs-keyword">if</span> (ttlRemaining == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1</span>) &#123;<br>                internalLockLeaseTime = unit.toMillis(leaseTime);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 锁自动续时（看门狗机制）触发条件leaseTime == -1</span><br>                scheduleExpirationRenewal(threadId);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> ttlRemainingFuture;<br>&#125;<br></code></pre></td></tr></table></figure><p>tryLockInnerAsync 里面是尝试获取分布式锁的 lua 脚本<br>scheduleExpirationRenewal 锁自动续时, 看门狗机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T&gt; RFuture&lt;T&gt; <span class="hljs-title function_">tryLockInnerAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> &#123;<br>    <span class="hljs-keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,<br>            <span class="hljs-comment">// 如果key一开始就不存在，则直接创建一个key</span><br>            <span class="hljs-string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +<br>                    <span class="hljs-string">&quot;return nil; &quot;</span> +<br>                    <span class="hljs-string">&quot;end; &quot;</span> +<br>                    <span class="hljs-comment">// 这里是重入锁的实现，同一个线程多次获取锁只需要在value加1即可，value相当于一个加锁计数器</span><br>                    <span class="hljs-string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +<br>                    <span class="hljs-string">&quot;return nil; &quot;</span> +<br>                    <span class="hljs-string">&quot;end; &quot;</span> +<br>                    <span class="hljs-comment">// 有其他线程持有锁，加锁失败，返回锁过期时间</span><br>                    <span class="hljs-string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,<br>            Collections.singletonList(getRawName()), unit.toMillis(leaseTime), getLockName(threadId));<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>加锁的 key 不存在就创建一个 redis hash key, field(当前线程 id), value(加锁次数)</li><li>有线程持有锁并且未解锁, 其他线程无法获取到锁</li><li>加锁成功返回 null, 加锁失败返回过期时间</li></ol><p>锁过期时间自动续费</p><ol><li>锁过期自动续费的触发条件为 tryLock 设置的锁到期时间为-1</li><li>自动续费的原理是创建一个定时任务, 每 internalLockLeaseTime &#x2F; 3 时触发一次, 如果发现持有锁未释放, 把锁过期时间更新为 internalLockLeaseTime(默认为 30s)</li><li>锁过期时间更新后, 再次递归调用 renewExpiration 创建下一次定时任务</li></ol><p>前面 tryLock 方法的订阅解锁消息通知是在 unlock 的时候发起的<br>unlockAsync 方法内部调用 lua 脚本, 调用 publish 推送解锁消息</p><p>Redis 的 publish</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs redis">publish channel message<br></code></pre></td></tr></table></figure><ul><li>channel 指定要发布消息的频道</li><li>message 要发布的消息内容<br>在 tryLock 和 unLock 中, 他们的 channel 是线程 id</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2024/05/28/Spring/"/>
    <url>/2024/05/28/Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h2><ul><li>通过 BeanDefinition 获取 Bean 的定义信息</li><li>通过构造函数实例化 Bean</li><li>Bean 的依赖注入</li><li>处理 Aware 接口</li><li>BeanPostProcessor - 前置方法</li><li>初始化方法(InitializingBean, init-method)</li><li>BeanPostProcessor - 后置方法</li><li>销毁 Bean</li></ul><p>BeanDefinition 是 Spring 容器在进行实例化时, 会将 xml 配置的 <code>&lt;bean&gt;</code> 信息封装成一个 BeanDefinition 对象, Spring 根据它来创建 Bean 对象<br><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240305171200.png" alt="image.png"></p><h2 id="Aware-接口有什么用"><a href="#Aware-接口有什么用" class="headerlink" title="Aware 接口有什么用"></a>Aware 接口有什么用</h2><ul><li>通过实现特定的 Aware 接口, bean 可以获得对 Spring 容器的某些部分(如配置文件, 文件资源, 环境属性等) 的访问权</li><li>ApplicationContextAware: 允许一个 bean 获得对 ApplicationContext 的访问, 意味着该 bean 可以访问 Spring 容器的所有配置信息的定义</li><li>BeanNameAware: 它会在创建过程中接收到自己在容器中的名称</li><li>BeanFactoryAware: Bean 可以直接访问到它所在的 BeanFactory, 从而允许请求其他 Bean 等操作</li><li>实现这些接口可以让不是在 Spring 的环境下, 获取 Spring 的 Bean, 例如通过 BeanFactory</li></ul><h2 id="InitializingBean-有什么作用"><a href="#InitializingBean-有什么作用" class="headerlink" title="InitializingBean 有什么作用"></a>InitializingBean 有什么作用</h2><ul><li>用于在初始化方法完成后执行自定义初始化逻辑</li><li>当一个 Bean 实现了 InitializingBean 接口时, Spring 容器在初始化Bean 并完成所有属性设置后会调用 <code>afterPropertiesSet()</code> 方法来执行额外初始化操作</li></ul><h2 id="Spring-出现循环依赖"><a href="#Spring-出现循环依赖" class="headerlink" title="Spring 出现循环依赖"></a>Spring 出现循环依赖</h2><ul><li>循环依赖是指两个或多个 Bean 相互依赖, A 依赖于 B, B 依赖于 A</li></ul><h3 id="构造器注入循环依赖能解决吗"><a href="#构造器注入循环依赖能解决吗" class="headerlink" title="构造器注入循环依赖能解决吗"></a>构造器注入循环依赖能解决吗</h3><ul><li>如果 A 和 B 都用构造器注入不行, 因为在创建 Bean 实例时需要调用构造函数创建 Bean</li><li>但是一个使用 Setter 注入, 一个使用构造器注入需要分情况考虑<ul><li>A 用 Setter 注入 B, B 用构造器注入 A, 可以解决循环依赖</li><li>A 用构造器注入 B, B 用 Setter 注入 A, 不可以解决</li><li>因为 Spring 在创建 Bean 的时候默认是按照自然排序进行创建, A 会优先于 B 创建</li></ul></li></ul><h2 id="Spring-创建-Bean-简单的三步"><a href="#Spring-创建-Bean-简单的三步" class="headerlink" title="Spring 创建 Bean 简单的三步"></a>Spring 创建 Bean 简单的三步</h2><ul><li>实例化: 对应方法 <code>AbstractAutowireCapableBeanFactory</code> 的 <code>createBeanInstance</code> 方法</li><li>属性注入: 对应方法 <code>AbstractAutowireCapableBeanFactory</code> 的 <code>populateBean</code> 方法</li><li>初始化: 对应方法 <code>AbstractAutowireCapableBeanFactory</code> 的 <code>initializeBean</code><br>其实就是</li><li>实例化, new 了一个对象</li><li>属性注入: 为 new 的对象填充属性</li><li>初始化: 执行 aware 接口中的方法, 完成 AOP 代理</li></ul><h2 id="Spring-三级缓存"><a href="#Spring-三级缓存" class="headerlink" title="Spring 三级缓存"></a>Spring 三级缓存</h2><ul><li><code>singletonObjects</code> 一级缓存: 存储创建好的单例 Bean</li><li><code>earlySingletonObjects</code> 二级缓存: 完成实例化, 还未进行属性注入及初始化的对象</li><li><code>singletonFactories</code> 三级缓存: 提前暴露一个单例工厂, 二级缓存中存储的就是从这个工厂中获取的对象</li></ul><h2 id="SpringMVC-的执行流程"><a href="#SpringMVC-的执行流程" class="headerlink" title="SpringMVC 的执行流程"></a>SpringMVC 的执行流程</h2><ul><li>用户发送请求到前端控制器 DispatchServlet</li><li>DispatchServlet 收到请求, 调用 HandlerMapper</li><li>HandlerMapper 找到具体的处理器, 生成处理器对象及处理器拦截器(如果有) 一起返回 DispatchServlet</li><li>DispatchServlet 调用 HandlerAdapter(处理器适配器)</li><li>HandlerAdapter 调用具体的 Controller</li></ul><h2 id="SpringBoot-自动装配原理-or-启动流程"><a href="#SpringBoot-自动装配原理-or-启动流程" class="headerlink" title="SpringBoot 自动装配原理 or 启动流程"></a>SpringBoot 自动装配原理 or 启动流程</h2><ul><li>在 SpringBoot 启动类上有一个 <code>@SpringBootApplication</code> 注解, 其中封装了三个注解<ul><li><code>@SpringBootConfiguration</code></li><li><code>@EnableAutoConfiguration</code></li><li><code>@ComponentScan</code></li></ul></li><li>其中 <code>@EnableAutoConfiguration</code> 是实现自动配置的核心注解, 该注解通过 <code>@Import</code> 注解导入对应的配置选择器类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br></code></pre></td></tr></table></figure></li><li>配置选择器类内部读取该项目和该项目引用 jar 包的 classpath 路径下的 META-INF&#x2F;spring.factories 文件, 该文件里有所需要加载的类的全限定类名, 会根据 bean 的条件注解决定是否将其导入 Spring 容器中<ul><li>条件注解有像 <code>@ConditionalOnClass</code> 这样的注解, 表示有对应的 class 文件, 才加载</li></ul></li></ul><h2 id="SpringBoot-依赖管理"><a href="#SpringBoot-依赖管理" class="headerlink" title="SpringBoot 依赖管理"></a>SpringBoot 依赖管理</h2><ul><li>继承了 <code>spring-boot-starter-parent</code>  其又继承了 <code>spring-boot-dependencies</code> 内部定义了很多依赖</li></ul><h2 id="spring-boot-starter-跟-spring-boot-starter-web-有什么区别"><a href="#spring-boot-starter-跟-spring-boot-starter-web-有什么区别" class="headerlink" title="spring-boot-starter 跟 spring-boot-starter-web 有什么区别"></a>spring-boot-starter 跟 spring-boot-starter-web 有什么区别</h2><ul><li><code>spring-boot-starter</code> 是许多其他 Starter 的基础依赖, 但不包含任何特定的功能模块, 它包含以下内容<ul><li>Spring Core</li><li>Spring Context</li><li>Spring AOP</li></ul></li><li><code>spring-boot-starter-web</code> 是专门用于构建 Web 应用的 Starter 依赖, 能处理 HTTP 请求, 它里面包含 <code>spring-boot-starter</code> <ul><li>Spring Web</li><li>Spring MVC</li><li>Jackson</li><li>Tomcat</li></ul></li></ul><h2 id="Spring-常用的类"><a href="#Spring-常用的类" class="headerlink" title="Spring 常用的类"></a>Spring 常用的类</h2><ul><li><code>ApplicationContext</code> Spring 容器接口, 负责创建和管理 Spring Bean</li><li><code>BeanFactory</code> Spring 容器, 提供 Bean 的基础管理</li><li><code>BeanDefinition</code> </li><li><code>InitializingBean</code></li><li>一些 Aware 接口</li></ul><h2 id="Spring-自动注入原理"><a href="#Spring-自动注入原理" class="headerlink" title="Spring 自动注入原理"></a>Spring 自动注入原理</h2><ul><li>使用反射机制将依赖注入到 Bean 中<ul><li>构造器注入</li><li>Setter 方法注入</li><li>字段注入</li></ul></li></ul><h2 id="get-和-post-有什么区别"><a href="#get-和-post-有什么区别" class="headerlink" title="get 和 post 有什么区别"></a>get 和 post 有什么区别</h2><ul><li>get 参数拼接在 Url 后面, post 参数在请求体里, 相对安全</li><li>数据大小限制, get 受到 Url 长度的限制, post 理论上没有大小限制</li><li>幂等性, get 是幂等的, post 是非幂等的</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU</title>
    <link href="/2024/05/28/%E5%8A%9B%E6%89%A3-LRU/"/>
    <url>/2024/05/28/%E5%8A%9B%E6%89%A3-LRU/</url>
    
    <content type="html"><![CDATA[<h1 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h1><p>LRU，Least Recently Used，最少最近使用，淘汰策略是最久没用的<br>想象有一摞书，用的时候抽出来，放在最上面<br>淘汰的时候把最下面的移除<br>整一个双向链表，每次都淘汰最后一个，插入的时候插入到头（哨兵后面）<br><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240314221217.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>        <span class="hljs-type">int</span> key, value;<br>        Node pre, next;<br>        Node(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)&#123;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 哨兵节点</span><br>    <span class="hljs-comment">// 存储 key 和 Node 的关系，方便检索</span><br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Node&gt; key2Node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>(); <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        dummy.pre = dummy;<br>        dummy.next = dummy;<br>    &#125;<br>    <span class="hljs-comment">// 移除某一个节点（抽出一本书）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Node node)</span>&#123;<br>        node.pre.next = node.next;<br>        node.next.pre = node.pre;<br>    &#125;<br>    <span class="hljs-comment">// 把节点添加到链表头（把一本书放到最上面）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushFront</span><span class="hljs-params">(Node node)</span>&#123;<br>        node.pre = dummy;<br>        node.next = dummy.next;<br>        node.pre.next = node;<br>        node.next.pre = node;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span>&#123;<br>        <span class="hljs-keyword">if</span> (!key2Node.containsKey(key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> key2Node.get(key);  <span class="hljs-comment">// 如果有的话，最近使用过</span><br>        <span class="hljs-comment">// 要把它放到最上面，也就是先移除再插入</span><br>        remove(node);<br>        pushFront(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNode(key);<br>        <span class="hljs-keyword">return</span> node == <span class="hljs-literal">null</span> ? -<span class="hljs-number">1</span> : node.value;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNode(key);<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>)&#123;  <span class="hljs-comment">// 有这本书</span><br>            node.value = value;  <span class="hljs-comment">// 更新 value</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, value);  <span class="hljs-comment">// 新书</span><br>        key2Node.put(key, node);<br>        pushFront(node);  <span class="hljs-comment">// 放到最上面</span><br>        <span class="hljs-keyword">if</span> (key2Node.size() &gt; capacity)&#123;  <span class="hljs-comment">// 淘汰策略</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">backNode</span> <span class="hljs-operator">=</span> dummy.pre;<br>            key2Node.remove(backNode.key);<br>            remove(backNode);  <span class="hljs-comment">// 移除最后一个</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2024/05/27/MySQL/"/>
    <url>/2024/05/27/MySQL/</url>
    
    <content type="html"><![CDATA[<ul><li><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="redo-log-和-binlog-的区别"><a href="#redo-log-和-binlog-的区别" class="headerlink" title="redo log 和 binlog 的区别"></a>redo log 和 binlog 的区别</h2><ul><li>redo log 是 InnoDB 特有的, binlog 是 Server 层的每个数据引擎都有</li><li>redo log 记录的是物理日志, 记录的是在某个数据页做的修改, 比如”对 xxx 表中 yyy 数据页 zzz 偏移量的地方坐了 aaa 更新” binlog 是逻辑日志, 记录的是这个语句的原始逻辑, 比如”给 id &#x3D; 2 的字段 c 加 1”</li><li>redo log 是循环写的, 空间会用完, binlog 是追加写的</li></ul><h2 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a>聚簇索引和二级索引</h2><ul><li>InnoDB 使用了 B+ 树索引模型</li><li>主键索引的叶子节点存储的是整行数据, 在 InnoDB 中, 主键索引也被称为聚簇索引</li><li>非主键索引的叶子节点存储的是主键值, 在 InnoDB 中, 非主键索引也被称为二级索引</li></ul><h2 id="为什么用-B-树做索引"><a href="#为什么用-B-树做索引" class="headerlink" title="为什么用 B+ 树做索引"></a>为什么用 B+ 树做索引</h2><h3 id="什么样的数据结构是好的索引"><a href="#什么样的数据结构是好的索引" class="headerlink" title="什么样的数据结构是好的索引?"></a>什么样的数据结构是好的索引?</h3><ul><li>MySQL 是持久化到磁盘的, 因此当我们通过索引查找某行数据的时候, 需要先从磁盘读取索引到内存, 再通过索引从磁盘中找到某行数据, 然后读入内存, 也就是说查询的过程中会发生多次 IO 操作, IO 操作次数越多, 性能损耗越大</li><li>MySQL 是支持范围查找的, 所以索引数据不仅能高效查找某一个记录, 而且也要能高效执行范围查找</li><li>所以一个合适的索引要满足<ul><li>尽可能少的进行 IO 操作</li><li>能高效查找某一个记录, 也能高效进行范围查找</li></ul></li></ul><h3 id="各个数据结构对比"><a href="#各个数据结构对比" class="headerlink" title="各个数据结构对比"></a>各个数据结构对比</h3><ul><li>顺序结构, 可以用二分来查找, 速度快, 但是插入性能太低</li><li>二叉搜索树, 不支持范围查找, 而且有退化成链表的风险</li><li>平衡二叉树, 不支持范围查找, 并且由于是二叉树, 随着元素增多, 树的高度变高, 磁盘 IO 次数增加</li><li>B 树, B 树可以是多叉树, 但是每个节点都存储索引+数据, 而数据的大小可能远远超过索引大小</li><li>B+树, 叶子结点才会存放实际数据, 非叶子节点只会存放索引, 叶子节点构成一个有序链表</li></ul><h3 id="InnoDB-中的-B-树"><a href="#InnoDB-中的-B-树" class="headerlink" title="InnoDB 中的 B+ 树"></a>InnoDB 中的 B+ 树</h3><ul><li>叶子节点用双向链表进行连接, 既能向左遍历, 也能向右遍历</li><li>叶子节点内容是数据页, 数据页存放了数据以及各种信息, 每个数据页默认大小 16KB</li></ul><h2 id="什么是两阶段锁"><a href="#什么是两阶段锁" class="headerlink" title="什么是两阶段锁"></a>什么是两阶段锁</h2><ul><li>在 InnoDB 事务中, 行锁是在需要的时候加上的, 但并不是不需要了就立即释放, 而是等到事务结束才释放</li></ul><h2 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h2><ul><li>快照读中, 事务读取的是数据快照, 即事务开始时的数据状态</li><li>当前读中, 事务读取的是数据库当前数据状态, 即最新数据, 如果有锁的话阻塞等待</li><li>可重复读的隔离级别下<ul><li>select 默认快照读</li><li>select 加锁是当前读<ul><li>select a from t where id &#x3D; 1 lock in share mode 共享锁</li><li>select a from t where id for update 排他锁</li></ul></li><li>update 语句是当前读</li></ul></li></ul><h2 id="索引创建原则"><a href="#索引创建原则" class="headerlink" title="索引创建原则"></a>索引创建原则</h2><ul><li>数据量大, 且查询频繁的时候要创建索引</li><li>为常作为查询条件, 排序, 分组的字段创建索引</li><li>字段的内容区分度要高</li><li>内容较长的情况下, 使用前缀索引</li><li>尽量使用联合索引, 这样可以进行覆盖查询, 方式回表</li><li>要控制索引的数量</li></ul><h2 id="什么情况下索引会失效"><a href="#什么情况下索引会失效" class="headerlink" title="什么情况下索引会失效"></a>什么情况下索引会失效</h2><ul><li>联合索引中违反最左前缀法则</li><li>联合索引中范围查询的右边的列, 不能使用索引</li><li>索引列上进行运算操作, 索引失效</li><li>索引列进行类型转换, 比如字符串不加单引号, 索引失效</li><li>以%开头的 like 模糊查询, 索引失效</li></ul><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><ul><li>是一种快速搜索文本数据的索引, 适用于需要处理大量自然语言文本的应用场景</li><li>底层由倒排索引实现<ul><li>词典: 存储每一个词</li><li>倒排列表: 记录每个词在文档中出现的位置</li></ul></li></ul><h2 id="慢查询出现的原因"><a href="#慢查询出现的原因" class="headerlink" title="慢查询出现的原因"></a>慢查询出现的原因</h2><ul><li>没有使用索引或者索引不当</li><li>复杂的 join 操作, 尤其涉及大量数据的表</li><li>子查询过多</li><li>表结构设计不合理, 过多的冗余设计</li><li>数据量过大</li><li>服务器的硬件资源不粗</li></ul><h2 id="优化慢查询"><a href="#优化慢查询" class="headerlink" title="优化慢查询"></a>优化慢查询</h2><ul><li>先运行看看是否真的很慢，注意设置 SQL_NO_CACHE</li><li>WHERE 条件单表查，锁定最小返回记录表<ul><li>在涉及多个表的查询中，应该从返回记录最少的表开始查询，以减少数据处理的开销</li><li>对于单表查询，通过 WHERE 条件逐个应用到表中的每个字段，找出区分度最高的字段，这样可以更高效地过滤数据<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 假设有两个表</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> A, B <span class="hljs-keyword">WHERE</span> A.id <span class="hljs-operator">=</span> B.id <span class="hljs-keyword">AND</span> A.status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;active&#x27;</span> <span class="hljs-keyword">AND</span> B.type <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;premium&#x27;</span>;<br><span class="hljs-comment">-- 分析单标 where 条件效果</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> A <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;active&#x27;</span>; <span class="hljs-comment">-- 结果记录数较多</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> B <span class="hljs-keyword">WHERE</span> type <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;premium&#x27;</span>;  <span class="hljs-comment">-- 结果记录数较少</span><br><span class="hljs-comment">-- 优先从记录较少的 B 表开始查</span><br></code></pre></td></tr></table></figure></li></ul></li><li>使用 EXPLAIN 查看查询的执行计划，确认查询是从记录较少的表开始的，并检查索引的使用情况</li><li>在 ORDER BY … LIMIT … 的查询中，应该优先处理排序的表，这样可以减少排序和截取结果的开销</li></ul><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><ul><li>A 原子性: 事务是不可分割的最小单位, 要么全部成功, 要么全部失败</li><li>C 一致性: 事务完成时, 必须使所有的数据都保持一致状态</li><li>I 隔离性: 数据库系统提供的隔离机制, 保证事务在不收外部并发操作的影响的独立环境下运行</li><li>D 持久性: 事务一旦提交或回滚, 它对数据库的改变是永久的</li></ul><h2 id="并发事务带来了哪些问题"><a href="#并发事务带来了哪些问题" class="headerlink" title="并发事务带来了哪些问题"></a>并发事务带来了哪些问题</h2><ul><li>脏读</li><li>不可重复度</li><li>幻读: 一个事务按照条件查询, 没有对应的记录, 但是插入的时候发现记录已存在, 好像出现了幻影</li></ul><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><ul><li>多版本并发控制, 主要是通过隐藏字段(事务 id, roll_pointer), undo log 版本链和 ReadView组成的</li><li>它维护了一条数据的多个版本, 用 roll_pointer 进行连接, 形成一个 undo log 链</li><li>ReadView 快照读<ul><li>读已提交: 每次 select 都会生成快照</li><li>可重复读: 第一次 select 生成快照, 之后复用</li></ul></li></ul><p>对于一个事务视图来说, 除了自己更新总是可见的以外, 还有 3 种情况</p><ul><li>版本未提交, 不可见</li><li>版本已提交, 但是在视图创建后提交的, 不可见</li><li>版本已提交, 而且实在视图创建前提交的, 可见</li></ul><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>当同一个查询在不同的时间产生不同的结果集时, 事务中就会出现所谓的幻象, 例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>在 T1 时刻和 T2 时刻分别执行以下语句, 得到的结果集是不相同的<br>例如 T1 时刻有 5 条记录, 而 T2 时刻有 6 条记录<br>在可重复度级别下<br><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240514195706.png" alt="image.png"><br>前后两次查询结果是一样的, 没有出现幻读, 因为在可重复度级别下 select 执行的时候会创建一个快照, 在快照上读肯定没有幻读<br>但是当前读会出现幻读, 因为当前读都会查询最新版本数据, 然后再做进一步操作</p><ul><li>update</li><li>insert</li><li>delete</li><li>select … for update 都是当前读<br>我们假设 select … for update 是不会加锁, (实际上是会加锁的)<br><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240514195938.png" alt="image.png"><br>由于 select … for update 是当前读, 所以就会出现两次查询结果不一样的情况<br>所以 InnoDB 为了解决可重复读使用当前读而造成的幻读问题, 引入了间歇锁<br><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240514200205.png" alt="image.png"><br>事务 A 执行语句后就会在 id 范围为(2, +∞] 的 next-key lock(间歇锁 + 记录锁)<br>事务 B 在执行插入语句的时候, 判断插入位置被 A 加上了 next-key lock, 于是事务 B 会生成一个插入意向锁, 等待</li></ul><p>还有几种情况<br>详见小林 coding <a href="https://xiaolincoding.com/mysql/transaction/phantom.html">https://xiaolincoding.com/mysql/transaction/phantom.html</a></p><h2 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h2><ul><li>核心是 binlog 日志</li><li>从库读取主库的 binlog, 写入到从库的中继日志 Relay Log 中</li><li>从库执行中继日志的事务, 同步数据</li></ul><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><ul><li>水平分库</li><li>水平分表</li><li>垂直分库</li><li>垂直分表: 冷热数据分离, 多表互不影响(把表中某些字段分出去)</li></ul><h2 id="范围查找流程"><a href="#范围查找流程" class="headerlink" title="范围查找流程"></a>范围查找流程</h2><h3 id="有索引"><a href="#有索引" class="headerlink" title="有索引"></a>有索引</h3><p>比如找到 id &gt;&#x3D; 20 and &lt; 49的数据<br>1、加载根数据页到内存<br>2、在内存中做二分，找到对应的子页<br>3、在子页做二分，找到对应的子页<br>4、现在到了叶子节点页，在页中做二分，找到第一条满足的数据，这里是 id &#x3D; 20<br>5、一直通过叶子节点的链表指针，找到第一条不满足的为止，这里是 id &#x3D; 49<br>6、结束查找，返回数据</p><h3 id="没有索引"><a href="#没有索引" class="headerlink" title="没有索引"></a>没有索引</h3><ul><li>扫描全表</li></ul><h2 id="如何避免主从延迟"><a href="#如何避免主从延迟" class="headerlink" title="如何避免主从延迟"></a>如何避免主从延迟</h2><ul><li>强制将读请求路由到主库处理, 对于必须获取最新数据的请求, 都交给主库处理</li><li>延迟读取, 对于一些对数据比较敏感的场景, 可以在完成写请求之后, 避免立刻进行请求操作<ul><li>比如支付成功之后, 跳转到支付成功的页面, 当点击返回的时候才返回自己的账户</li></ul></li></ul><h2 id="MySQL-主键自增策略"><a href="#MySQL-主键自增策略" class="headerlink" title="MySQL 主键自增策略"></a>MySQL 主键自增策略</h2><ul><li>自增</li><li>UUID</li><li>雪花算法</li></ul><h2 id="MySQL-的索引类型"><a href="#MySQL-的索引类型" class="headerlink" title="MySQL 的索引类型"></a>MySQL 的索引类型</h2><ul><li>普通索引</li><li>唯一索引</li><li>主键索引, 一般在创建表的时候指定</li><li>联合索引</li><li>全文索引</li></ul><h2 id="间隙锁导致死锁"><a href="#间隙锁导致死锁" class="headerlink" title="间隙锁导致死锁"></a>间隙锁导致死锁</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务A</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> course <span class="hljs-keyword">where</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> course(id, user_id, <span class="hljs-keyword">no</span>) <span class="hljs-keyword">VALUE</span> (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;3&#x27;</span>);<br><br><span class="hljs-comment">-- 事务B</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> course <span class="hljs-keyword">where</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> course(id, user_id, <span class="hljs-keyword">no</span>) <span class="hljs-keyword">VALUE</span> (<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;4&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="日志有哪些"><a href="#日志有哪些" class="headerlink" title="日志有哪些"></a>日志有哪些</h2><ul><li>BinLog 日志</li><li>慢查询日志</li><li>Relay Log</li><li>Undo Log</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2024/05/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/05/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="Runnable-和-Callable-有什么区别"><a href="#Runnable-和-Callable-有什么区别" class="headerlink" title="Runnable 和 Callable 有什么区别"></a>Runnable 和 Callable 有什么区别</h2><ul><li>Runnable 的 run 方法没有返回值, Callable 的 call 方法有</li><li>Callable 的 call 方法是个泛型</li><li>Runnable 的 run 方法不能抛异常, Callable 的 call 方法可以</li></ul><h2 id="wait-和-sleep-方法有什么区别"><a href="#wait-和-sleep-方法有什么区别" class="headerlink" title="wait 和 sleep 方法有什么区别"></a>wait 和 sleep 方法有什么区别</h2><ul><li>归属不同: wait 方法是 Object 类中的, sleep 方法是 Thread 的静态方法</li><li>醒来时机不同: sleep(long) 和 wait(long) 都会在等待相应毫秒后醒来, wait 方法可以被 notify 唤醒</li><li>锁特性不同: wait 方法必须配合Synchronized 使用, sleep 无此限制<ul><li>wait 方法执行后会释放锁对象, 允许其他线程获得锁(我放弃 CPU, 你们可以用)</li><li>sleep 如果在 Synchronized 代码块中执行, 不会释放锁对象(我放弃 CPU, 你们也不能用)</li></ul></li></ul><h2 id="Synchronized-底层原理"><a href="#Synchronized-底层原理" class="headerlink" title="Synchronized 底层原理"></a>Synchronized 底层原理</h2><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><ul><li>在 1.7 版本中 ConcurrentHashMap 是用 数组 + 链表的数据结构实现的<ul><li>数组又分大数组 Segment 和小数组 HashEntry (大数组可以理解为 MySQL 的数据库, 小数组可以理解为表, 每个数组可以存储多条数据, 用链表连接)</li><li>它是基于 ReentrantLock 实现加锁和释放锁的操作, 锁的粒度为 Segment</li></ul></li><li>在 1.8 版本中用的是 数组 + 链表 + 红黑树的数据结构实现的<ul><li>用的是 CAS + volatile 或 Synchronized 方式保证线程安全</li><li>添加元素首先会判断容器是否为空, 如果为空则用 volatile + CAS 初始化</li><li>容器不为空则根据存储的元素计算位置是否为空, 为空用 CAS 设置节点</li><li>不为空则使用 Synchronized 加锁</li></ul></li></ul><h2 id="JMM-内存结构"><a href="#JMM-内存结构" class="headerlink" title="JMM 内存结构"></a>JMM 内存结构</h2><h2 id="介绍一下volatile-关键字"><a href="#介绍一下volatile-关键字" class="headerlink" title="介绍一下volatile 关键字"></a>介绍一下volatile 关键字</h2><ul><li>是用来修饰变量的</li><li>被其修饰的变量在修改后可以立即同步到主内存, 每次使用之前都是从主内存读取, 因此 volatile 可以保证可见性</li><li>volatile 可以禁止指令重排序, 被 volatile 修饰的变量操作, 会严格按照代码顺序执行</li></ul><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><ul><li>抽象队列同步器</li><li>内部维护了一个先进先出的双向队列, 队列中存储的是排队的线程</li><li>AQS 内部有一个属性 state, 相当于资源, 默认是 0, 当有一个线程成功修改 state 为 1, 则当前线程就等于获取了资源</li><li>对 state 修改的时候用 CAS 操作, 保证多个线程修改情况下的原子性</li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h2 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h2><h2 id="用线程池有什么好处"><a href="#用线程池有什么好处" class="headerlink" title="用线程池有什么好处"></a>用线程池有什么好处</h2><ul><li>不用反复创建收回线程所需要的资源</li><li>系统的响应速度更快</li><li>更加合理利用 CPU 资源</li><li>可以统一管理资源</li></ul><h2 id="线程池的创建方法"><a href="#线程池的创建方法" class="headerlink" title="线程池的创建方法"></a>线程池的创建方法</h2><ul><li>ThreadPoolExecutor 构造函数</li><li>Executors 工具类</li></ul><h2 id="什么时候使用线程池"><a href="#什么时候使用线程池" class="headerlink" title="什么时候使用线程池"></a>什么时候使用线程池</h2><ul><li>当需要频繁创建和销毁线程的时候</li><li>常量池的参数配置<ul><li>快速响应用户请求, 用户发起试试请求, 服务追求响应时间, 比如一个用户要查看商品信息, 那么响应越快越好, 所以这种场景不应该设置队列去缓存并发任务, 调高 corePoolSize 和 maxPoolSize 尽可能创造多的线程执行任务</li><li>批处理操作, 离线计算大量任务, 比如统计报表, 这种情况下, 任务量巨大不需要瞬时完成, 也就是吞吐量优先, 所以应该设置队列去缓冲并发任务</li></ul></li></ul><h2 id="notify-和-wait"><a href="#notify-和-wait" class="headerlink" title="notify 和 wait"></a>notify 和 wait</h2><ul><li>wait 和 notify 均依赖于锁, 且锁的对象必须是同一个对象, 否则无法执行唤醒</li><li>notify 唤醒是随机唤醒一个线程, 唤醒的范为是同一锁对象, 所有 wait 的线程</li></ul><p>notify 同一依赖于锁, 必须在同步快中执行, 执行之后会立刻释放锁吗?</p><ul><li>notify 在执行后不会立即唤醒, 而是等到 notify 同步块执行完之后才会去执行唤醒</li></ul><h2 id="wait-notify-和-await-signal-关系"><a href="#wait-notify-和-await-signal-关系" class="headerlink" title="wait&#x2F;notify 和 await&#x2F;signal 关系"></a>wait&#x2F;notify 和 await&#x2F;signal 关系</h2><ul><li>wait&#x2F;notify <ul><li>基于 Synchronized 实现的</li><li>无法控制唤醒谁, 随机唤醒</li></ul></li><li>await&#x2F;signal <ul><li>基于 Lock 实现的</li><li>使用 Condition 对象可以细粒度低控制线程的等待和唤醒</li></ul></li></ul><h2 id="Executors-工具类提供的四个线程池子"><a href="#Executors-工具类提供的四个线程池子" class="headerlink" title="Executors 工具类提供的四个线程池子"></a>Executors 工具类提供的四个线程池子</h2><ul><li><code>newSingleThreadExecutor()</code> 用于需要保证任务按顺序执行的场景<ul><li>corePoolSize: 1</li><li>maximumPoolSize: 1</li><li>阻塞队列: LinkedBlockingQueue 大小是 Integer.MAX_VALUE</li></ul></li><li><code>newFixedThreadPool(int nThreads)</code> 用于负载稳定、任务量恒定的场景<ul><li>corePoolSize: nThreads</li><li>maximumPoolSize: nThreads</li><li>阻塞队列: LinkedBlockingQueue 大小是 Integer.MAX_VALUE</li></ul></li><li><code>newCachedThreadPool()</code> 适用于执行大量短期异步任务的场景，能高效地利用系统资源<ul><li>corePoolSize: 0</li><li>maximumPoolSize: Integer.MAX_VALUE</li><li>阻塞队列: 大小为 0</li></ul></li><li><code>ScheduledThreadPoolExecutor(int corePoolSize)</code> 用于需要定时或周期性执行任务的场景<ul><li>corePoolSize: 0</li><li>maximumPoolSize: Integer.MAX_VALUE</li><li>阻塞队列: 大小无界, 按照延迟的时间长短对任务进行排序</li></ul></li></ul><h2 id="shutdown-和-shutdownNow"><a href="#shutdown-和-shutdownNow" class="headerlink" title="shutdown() 和 shutdownNow()"></a>shutdown() 和 shutdownNow()</h2><ul><li>shutdown(): 关闭线程池, 线程池的状态变为 SHUTDOWN, 线程池不再接受新任务, 但是队列里的任务得执行完毕</li><li>shutdownNow(): 关闭线程池, 线程池的状态变为 STOP, 线程池会终止当前正在运行的任务, 并停止处理排队的任务并返回正在等待执行的 List</li></ul><h2 id="isTerminated-和-isShutdown"><a href="#isTerminated-和-isShutdown" class="headerlink" title="isTerminated() 和 isShutdown()"></a>isTerminated() 和 isShutdown()</h2><ul><li>isShutdown(): 当调用 shutdown() 方法后返回 true</li><li>isTerminated: 当调用 shutdown() 方法后, 并执行完所有提交的任务后返回 true</li></ul><h2 id="如何正确使用线程池"><a href="#如何正确使用线程池" class="headerlink" title="如何正确使用线程池"></a>如何正确使用线程池</h2><ul><li>正确声明线程池, 用 ThreadExecutorPool 构造函数声明, 而不是 Executors 工具类(会有 OOM 的风险)</li><li>监测线程池运行状态, SpringBoot 的 Actuator 组件</li><li>建议不同业务使用不同的线程池</li><li>给线程池命名</li><li>别忘记关闭线程池</li><li>线程池尽量不要放耗时任务, 耗时任务用消息队列异步执行</li></ul><h2 id="动态调整线程池大小-美团"><a href="#动态调整线程池大小-美团" class="headerlink" title="动态调整线程池大小(美团)"></a>动态调整线程池大小(美团)</h2><ul><li>用 setCorePoolSize 调整核心线程池大小</li><li>用 setMaximumPoolSize 调整最大线程池大小</li><li>重写 LinkedBlockingQueue, 把里面的 capacity 字段的 final关键字去掉, 变为可变的</li></ul><h2 id="动态调整线程池大小-Nacos"><a href="#动态调整线程池大小-Nacos" class="headerlink" title="动态调整线程池大小(Nacos)"></a>动态调整线程池大小(Nacos)</h2><ul><li><code>@RefreshScope</code> 支持 Nacos 动态刷新</li><li><code>@Value(&quot;$&#123;max.size&#125;&quot;</code> 读取在 Nacos 配置的具体信息</li><li>配置监听, Nacos 配置变更时实时修改线程池配置</li></ul><h2 id="线程池中线程异常后-销毁还是复用"><a href="#线程池中线程异常后-销毁还是复用" class="headerlink" title="线程池中线程异常后, 销毁还是复用?"></a>线程池中线程异常后, 销毁还是复用?</h2><ul><li>使用 execute() 提交任务<ul><li>如果异常没有在任务内捕获, 那么该异常会导致当前线程终止, 控制台打印日志</li><li>线程池会检测到这种异常终止, 并创建一个新的线程来替换它, 从而保证配置的线程数不变</li></ul></li><li>使用 submit() 提交任务<ul><li>如果在执行中发生异常, 会封装在 submit() 返回的 <code>Future</code> 对象中</li><li>当调用 <code>Future.get()</code> 方法可以捕获到一个 <code>ExecutionException</code> </li><li>线程不会因异常终止, 会继续存在线程池中</li></ul></li></ul><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><ul><li>是用来做多个任务的编排的, 规定任务前后执行顺序</li><li>Future 不支持异步任务的编排, 获取计算结果的 <code>get()</code> 方法为阻塞调用</li></ul><h2 id="Java-不同锁的实现和使用场景"><a href="#Java-不同锁的实现和使用场景" class="headerlink" title="Java 不同锁的实现和使用场景"></a>Java 不同锁的实现和使用场景</h2><ul><li><code>synchronized</code> 关键字<ul><li>可重入锁</li><li>非公平锁</li></ul></li><li><code>ReentrantLock</code><ul><li>可重入锁</li><li>AQS 队列</li><li>可以实现公平锁</li></ul></li><li><code>ReadWrite Lock</code> 读写锁<ul><li>读锁是共享锁, 读读不互斥, 获取到读锁的时候, 无法获取写锁</li><li>写锁是独占锁, 加上写锁的时候别的线程读写都不行</li></ul></li></ul><h2 id="CountDownLatch-类-倒计时器"><a href="#CountDownLatch-类-倒计时器" class="headerlink" title="CountDownLatch 类(倒计时器)"></a>CountDownLatch 类(倒计时器)</h2><ul><li>CountDownLatch 允许 count 个线程阻塞在一个地方, 直至所有线程的任务都执行完毕</li><li>典型用法<ul><li>某一个线程在开始运行前等待 n 个线程执行完毕: 将 CountDownLatch 的计数器初始化为 n, 每当一个任务线程执行完毕, 就将计数器 -1, 当计数器的值变为 0 时, 在 CountDownLatch 上 await() 的线程就被唤醒<ul><li>典型应用场景就是启动一个服务时, 主线程需要等待多个组件加载完成, 之后再继续执行</li></ul></li><li>实现多个线程开始执行任务的最大并发性: 强调的是多个线程在某一时刻同时开始执行, 类似于赛跑, 将多个线程放到起点, 同时开跑, 初始化一个共享的 CountDownLatch 对象, 将其计数器初始化为 1, 多个线程在开始执行任务前首先 <code>countdownLathch.await()</code> 当主线程调用 countDown() 时, 计数器变为 0, 多个线程被同时唤醒</li></ul></li></ul><h2 id="如何预防死锁"><a href="#如何预防死锁" class="headerlink" title="如何预防死锁"></a>如何预防死锁</h2><ul><li>破坏请求与保持条件: 一次性申请所有资源</li><li>破坏不可剥夺条件: 占用部分资源的线程去申请其他资源时, 如果申请不到, 主动释放他所占用的资源</li><li>破坏循环等待条件: 按照顺序申请资源, 释放资源反序释放</li></ul><h2 id="java-多线程通信"><a href="#java-多线程通信" class="headerlink" title="java 多线程通信"></a>java 多线程通信</h2><ul><li>锁</li><li><code>wait/notify</code></li><li><code>volatile</code> </li><li>管道</li><li><code>join</code></li><li><code>ThreadLocal</code></li></ul><h2 id="如何检测死锁"><a href="#如何检测死锁" class="headerlink" title="如何检测死锁"></a>如何检测死锁</h2><ul><li><code>jstack</code> 命令可以查看 JVM 线程栈和堆内存的情况, 如果有死锁, 通常会输出 <code>Found one Java-level deadlock</code> 字样</li><li>实际项目可以用 <code>top</code> 查看 CPU 占用情况, 出现死锁会导致 CPU 内存占用过高</li></ul><h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><ul><li>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang</title>
    <link href="/2024/05/26/golang/"/>
    <url>/2024/05/26/golang/</url>
    
    <content type="html"><![CDATA[<h1 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h1><h2 id="init-和-mian-函数"><a href="#init-和-mian-函数" class="headerlink" title="init 和 mian 函数"></a>init 和 mian 函数</h2><ul><li>init 函数<ul><li>同一个 package 可以定义多个 init 方法<ul><li>同一个 package 不同文件 init 方法执行按照文件名先后顺序执行</li></ul></li><li>同一个 go 文件中可以重复定义 init 方法<ul><li>按定义顺序执行</li></ul></li><li>按照 import 顺序调用其他包的 init 函数</li><li>导入顺序 mian -&gt; A -&gt; B -&gt; C 则 init 执行的顺序正好相反</li><li>init 函数都在一个 goroutine 内执行</li><li>执行完之后再执行 main 函数<br>  <img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240523190103.png" alt="image.png"></li></ul></li></ul><h2 id="byte-和-rune-有什么区别"><a href="#byte-和-rune-有什么区别" class="headerlink" title="byte 和 rune 有什么区别"></a>byte 和 rune 有什么区别</h2><ul><li>都是字符类型, 都是别名类型</li><li>byte 本质是 uint8 类型的别名, 代表了 ASCII 码的一个字符</li><li>rune 本质是 int32 类型的别名, 代表了 UTF-8 字符</li></ul><h2 id="Go-struct-能不能比较"><a href="#Go-struct-能不能比较" class="headerlink" title="Go struct 能不能比较"></a>Go struct 能不能比较</h2><ul><li>如果 struct 有不能比较的字段, 就不能比较</li><li>只能比较是否相等, 不能比较大小</li><li>所有属性都相等并且顺序一致的 struct 才能比较</li></ul><h2 id="goroutine-和线程的区别"><a href="#goroutine-和线程的区别" class="headerlink" title="goroutine 和线程的区别"></a>goroutine 和线程的区别</h2><ul><li>内存占用<ul><li>goroutine 栈内存消耗为 2KB</li><li>Thread 消耗 1MB</li></ul></li><li>创建和销毁<ul><li>Thread 创建和销毁都是操作系统内核级别的, 通常由线程池管理</li><li>goroutine 由 Go runtime 负责创建, 创建销毁消耗非常小, 是用户级</li></ul></li><li>切换<ul><li>Thread 切换时, 需要保存各种寄存器</li><li>goroutine 切换只需要保存 3 个寄存器 <ul><li><code>PC 程序计数器</code></li><li><code>Stack Pointer 栈顶指针</code></li><li><code>BP 基址指针</code></li></ul></li></ul></li></ul><h2 id="slice-和数组的区别"><a href="#slice-和数组的区别" class="headerlink" title="slice 和数组的区别"></a>slice 和数组的区别</h2><ul><li>slice 的底层数据结构是数组</li><li>数组是定长的, slice 可以扩容</li><li>数组就是一片连续的内存, slice 实际上是一个结构体, 包含长度, 容量, 底层数组<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span>&#123;<br>array unsafe.Pointer <span class="hljs-comment">// 元素指针</span><br><span class="hljs-built_in">len</span> <span class="hljs-type">int</span> <span class="hljs-comment">// 数组长度</span><br><span class="hljs-built_in">cap</span> <span class="hljs-type">int</span> <span class="hljs-comment">// 容量</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>底层数据可以被多个 slice 指向, 所以对一个 slice 操作有可能影响其他 slice</li></ul><h2 id="map-实现原理"><a href="#map-实现原理" class="headerlink" title="map 实现原理"></a>map 实现原理</h2><ul><li>数据被放入一个由桶组成的有序数组中, 每个桶最多可以存放 8 个 <code>key/value</code> 对</li><li>key 的 Hash 值低位用于在该数组中定位到桶, 高 8 位用于在桶中区分 <code>key/value</code> 对</li><li>超了会链接到额外的溢出桶 <code>overflow uintptr</code> 所以数据结构为<ul><li>hash 数组</li><li>桶内 key-value 数组</li><li>溢出的桶链表</li></ul></li><li>当 Hash 超过阈值需要扩容时, 会分配一个新的桶数组, 一般是旧的 2 倍</li><li>go 不会一次全量拷贝, 耗时太大, 会在每次读写 map 的时候动态迁移</li></ul><h2 id="为什么会-Hash-冲突"><a href="#为什么会-Hash-冲突" class="headerlink" title="为什么会 Hash 冲突"></a>为什么会 Hash 冲突</h2><ul><li>通过哈希函数产生的哈希值是有限的, 数据可能比较多, 导致经过哈希函数处理后出现相同的哈希值</li></ul><h2 id="go-map-并发导致-panic-如何解决"><a href="#go-map-并发导致-panic-如何解决" class="headerlink" title="go map 并发导致 panic 如何解决"></a>go map 并发导致 panic 如何解决</h2><ul><li>go 中 map 不支持并发读写</li><li>使用 <code>sync.map</code></li></ul><h2 id="go-的垃圾回收"><a href="#go-的垃圾回收" class="headerlink" title="go 的垃圾回收"></a>go 的垃圾回收</h2><ul><li>无分代</li><li>不整理(回收过程中不对对象进行移动与整理)</li><li>并发(与用户代码并发执行)</li><li>三色标记清除法</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
