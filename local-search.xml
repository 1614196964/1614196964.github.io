<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Memcached为什么比Redis更能抗热点</title>
    <link href="/2024/10/17/Memcached%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94Redis%E6%9B%B4%E8%83%BD%E6%8A%97%E7%83%AD%E7%82%B9/"/>
    <url>/2024/10/17/Memcached%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94Redis%E6%9B%B4%E8%83%BD%E6%8A%97%E7%83%AD%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Memcached为什么比Redis更能抗热点"><a href="#Memcached为什么比Redis更能抗热点" class="headerlink" title="Memcached为什么比Redis更能抗热点"></a>Memcached为什么比Redis更能抗热点</h1><h2 id="热点问题的本质"><a href="#热点问题的本质" class="headerlink" title="热点问题的本质"></a>热点问题的本质</h2><p>热点 key 最主要的问题还是它会导致缓存的流量不均衡，会导致单节点流量过高，无法发挥集群的作用，整个Redis集群能支撑的QPS就退化成了单个实例能支撑的QPS了</p><h2 id="Memcached-为什么抗热点性能更好"><a href="#Memcached-为什么抗热点性能更好" class="headerlink" title="Memcached 为什么抗热点性能更好"></a>Memcached 为什么抗热点性能更好</h2><p>第一个是 Memcached 通过多线程可以利用多核，从而可以显著提升单个实例的吞吐，针对这种流量倾斜的情况可以更好的应对</p><p>下图是一个例子，假设每个CPU核能支撑5W QPS（不考虑其他的开销，比如多线程的开销，实现的不同），Memcached和Redis从集群维度都可以抗10W QPS，但是具体到热点请求，单个Redis实例就只能抗5W QPS了，这样两者的抗热点能力就差了一倍，线上我们的Memcached实例通常会开10个线程或者更多，Memcached和Redis单实例的吞吐能力会有更大的差异</p><p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20250109222030.png"></p><p>如果我们的机器只有1核，对于get&#x2F;set的操作Memcached的抗热点能力可能还不如Redis，因为多线程还会有一些部分额外的开销</p><p>第二个是Redis的一些数据结构的操作复杂度并不是O(1)，比如zrange，复杂度是O(log(N) + M)，如果对于有1000(对应N)个元素的zset取100(对应M)个，那它的开销肯定要远大于get，对于这些操作单个redis实例能支撑QPS会降低很多，那相应的抗热点能力也会更差</p><h2 id="Memcached-一定能抗热点吗"><a href="#Memcached-一定能抗热点吗" class="headerlink" title="Memcached 一定能抗热点吗"></a>Memcached 一定能抗热点吗</h2><p>绝大部分场景下Memcached抗热点能力还是能达到预期效果的，但是如果你的Key比较大，那这个结论就可能不成立了，对于大Key 它的瓶颈可能不在CPU而是在网卡的带宽上了</p><p>对于一些大Key的访问，可能几万QPS就能把网卡的带宽用满了，而且这个最坑的地方是，如果单个Memcached实例把网卡占满了，部署在这台机器上的其他实例也会受影响，所以我们尽量还是要避免一些大Key的情况，如果Key比较大那Memcached的抗热点能力也会显著下降</p><h2 id="热点处理方案"><a href="#热点处理方案" class="headerlink" title="热点处理方案"></a>热点处理方案</h2><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>通过 <code>LoadingCache</code> 将数据暂存到主调内存中，可以有效降低对缓存的压力</p><p>本地缓存对于的get&#x2F;set的操作实现比较简单，但是对于zrange这些涉及多个参数命令会麻烦一些，除了Key还需要传入一些其他的参数，比如from,limit等，如果将这些参数作为本地缓存的key，那可能出现参数变化本地缓存key失效的情况，比如有个zset使用时间作为score，我们需要按照时间倒序取前100个元素，如果from用Double.MAX_VALUE没什么问题，但是如果from使用的是System.currentTimeMillis，那每次请求参数都会变化，本地缓存就失效了</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Caffeine 淘汰策略</title>
    <link href="/2024/09/30/Caffeine%20%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
    <url>/2024/09/30/Caffeine%20%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Caffeine-淘汰策略"><a href="#Caffeine-淘汰策略" class="headerlink" title="Caffeine 淘汰策略"></a>Caffeine 淘汰策略</h1><p>使用了 W-TinyLFU 算法，该算法主要有两部分</p><ol><li>采用 Count-Min Sketch 算法降低频率信息带来的内存消耗</li><li>通过维护一个 PK 机制保障新上的热点数据能够被缓存</li></ol><h2 id="Count-Min-Sketch-算法"><a href="#Count-Min-Sketch-算法" class="headerlink" title="Count-Min Sketch 算法"></a>Count-Min Sketch 算法</h2><p>该算法首先认为：对于频率统计，我们其实不需要一个精确值。在存储数据时，它首先对 key 进行多种 hash 函数运算，然后在各个 hash 函数对应的二维数组索引位置的记录值 +1</p><p>多个 hash 算法是为了避免 hash 冲突</p><p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20250109213928.png"></p><p>为了解决这个问题，采用多个 hash 算法，假设使用四种 hash 算法从该 key 在所有 hash 算法下映射的位置取数值最低的一个数作为访问频率（上图访问频率为 1）</p><p>Caffeine 也利用了 Count-Min Sketch 的思想，但是它有稍微的变化</p><p>Caffeine 使用一维 long 数组用来记录数据的访问频率，数组的大小为2的 N 次方，由缓存大小决定。假设缓存大小是 100，数组的大小需要满足：</p><p>简单来说就是，数组的大小就是第一个大于等于缓存大小的 2 的 N 次方。如果缓存大小为 100，那么用于记录数据访问频率的数组大小就是128</p><h2 id="PK-机制"><a href="#PK-机制" class="headerlink" title="PK 机制"></a>PK 机制</h2><p>Caffeine 所有的数据都存储在 ConcurrentHashMap 中。在 Caffeine 中有三个用于存储引用的 LRU 队列，分别是</p><ul><li>Window Cache</li><li>Probation Cache</li><li>Protected Cache</li></ul><p>其中Probation Cache 和 Protected Cache 组成了 Main Cache。正常情况下，Window Cache 占比大小为 1%，Probation Cache 大小为剩下的 99% 的 20%，Protected Cache 大小为剩下的 99% 的 80%</p><p>新数据直接进入 Window 区，当 Window 区满了，就会根据 LRU 算法把 Candidate（即淘汰出来的元素）放到 Probation 区</p><p>如果在 Probation 区的数据被访问到，会直接进入到Protected区。如果Protected区满了，该区淘汰出的数据将降级到Probation区</p><p>如果 Probation 区满了，就把 Candidate 和 Probation 区的 Victim（将要淘汰的元素），两个进行 “PK”（比较两者频率大小），胜者将留在 Probation，输者就要被淘汰了。也就是说，实际上的数据淘汰，只在 Probation 区发生</p>]]></content>
    
    
    
    <tags>
      
      <tag>本地缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Memcached 和 Redis 内存管理</title>
    <link href="/2024/09/20/Memcached%20%E5%92%8C%20Redis%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2024/09/20/Memcached%20%E5%92%8C%20Redis%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Memcached-和-Redis-内存管理"><a href="#Memcached-和-Redis-内存管理" class="headerlink" title="Memcached 和 Redis 内存管理"></a>Memcached 和 Redis 内存管理</h1><p>传统的 C 语言的 malloc&#x2F;free 函数是最常用的分配和释放内存的方法，但是这种方法存在着很大的缺陷</p><ol><li>不匹配的malloc和free容易造成内存泄露</li><li>频繁调用会造成大量内存碎片无法回收重新利用，降低内存利用率</li><li>作为系统调用，其系统开销远远大于一般函数调用</li></ol><h2 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h2><p>Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题<br><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20241202224158.png"><br>首先从操作系统申请一大块内存，并将其分割成各种尺寸的块Chunk，并把尺寸相同的块分成组Slab Class<br>当Memcached接收到客户端发送过来的数据时首先会根据收到数据的大小选择一个最合适的Slab Class，然后通过查询Memcached保存着的该Slab Class内空闲Chunk的列表就可以找到一个可用于存储数据的Chunk。当一条数据库过期或者丢弃时，该记录所占用的Chunk就可以回收，重新添加到空闲列表中<br>Memcached的内存管理制效率高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。比如将100个字节的数据缓存到128个字节的Chunk中，剩余的28个字节就浪费掉了</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis为了方便内存的管理，在分配一块内存之后，会将这块内存的大小存入内存块的头部<br>在Redis中，并不是所有的数据都一直存储在内存中的。这是和Memcached相比一个最大的区别<br>当物理内存用完时，Redis可以将一些很久没用到的value交换到磁盘，Redis 只会缓存所有 key 的信息<br>如果 Redis 发现内存的使用量超过了某一个阈值，将会触发 swap 操作，将某些 key 对应的 value 持久化到磁盘中，同时在内存中清除。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 能存多少个 Key</title>
    <link href="/2024/09/07/Redis%20%E8%83%BD%E5%AD%98%E5%A4%9A%E5%B0%91%E4%B8%AA%20Key/"/>
    <url>/2024/09/07/Redis%20%E8%83%BD%E5%AD%98%E5%A4%9A%E5%B0%91%E4%B8%AA%20Key/</url>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Redis 的键值对存在哪里？ 哈希表</p><p>dictEntry 存储的是实际键值对，定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictEntry</span> &#123;<br>    <span class="hljs-type">void</span> *key;<br>    <span class="hljs-keyword">union</span> &#123;<br>        <span class="hljs-type">void</span> *val;<br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>        <span class="hljs-type">double</span> d;<br>    &#125; v;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictEntry</span> *next;<br>&#125; dictEntry;<br></code></pre></td></tr></table></figure><p>dictht是哈希表，它的定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictht</span> &#123;<br><br>    <span class="hljs-comment">//dictEntry数组链表</span><br>    dictEntry **table;<br>    <br>    <span class="hljs-comment">//数组的长度</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br>    <br>    <span class="hljs-comment">//数组掩码，等于size-1</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;<br>    <br>    <span class="hljs-comment">//键值个数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br>&#125; dictht;<br></code></pre></td></tr></table></figure><p>Redis 的 kv 里面不是直接存字符串 key 是 sds，value 是 redisObject</p><h2 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h2><p>因为每个数组下标对应一个链表，如果一个新的 key 算出的数组下标已经包含了其他的 dictEntry，只需要把新的 key 对应的 dictEntry 挂在链表的第一个位置即可（因为是新插入的，可能马上会用到）</p><h2 id="扩缩容"><a href="#扩缩容" class="headerlink" title="扩缩容"></a>扩缩容</h2><p>单纯依赖链表做冲突处理，链表会越来越长，读写效率差，所以需要对哈希表扩容</p><p>对于 Redis 来说，一个哈希结构内置了两个哈希表，一个用于使用，另一个平时闲置，待时机成熟，扩容一倍，将数据迁移到另一个哈希表中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dict</span> &#123;<br>    dictType *type;<br>    <span class="hljs-type">void</span> *privdata;<br>    dictht ht[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">long</span> rehashidx; <span class="hljs-comment">/* rehashing not in progress if rehashidx == -1 */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> iterators; <span class="hljs-comment">/* number of iterators currently running */</span><br>&#125; dict;<br></code></pre></td></tr></table></figure><p>其中 rehashidx 表示当前 dict 是否正在做 rehash，如果为 -1 表示没有 rehash，当 used &gt; 2^n 时候，需要扩容（rehashidx 表示ht[0] 在 rehash 的时候所在的索引值）</p><p>为了保证 Redis 单线程的高效性，整个 rehash 是渐进式的，全部迁移完成之后 rehashidx 置为 -1 对于key的路由来说，它依然先从dict[0]去找，如果找到了，就顺便把它迁移到dict[1]。如果没找到就要从dict[1]去找</p><h2 id="能存多少-key"><a href="#能存多少-key" class="headerlink" title="能存多少 key?"></a>能存多少 key?</h2><p>先说结论：最好千万级别</p><p>size 定义了数组的长度，由于它是 <code>unsigned long</code> （4 个字节）所以理论上可以存 2 ^ 32 个元素</p><p>官方回答说最好放 2.5 亿个键值对</p><p>原因：</p><ol><li>rehash 问题，导致内存异常增长，由于要为 <code>ht[1]</code> 分配空间，大小取决于 <code>ht[0]</code> 当前包含的数量</li><li>死键问题，Redis 将所有键值对保存在 dict 中，还有一个 <code>dict *expires</code> 用来保存过期键，如果键值数量过多，并设置了过期时间，会导致内存占用</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">redisDb</span> &#123;<br>    dict *dict;    <span class="hljs-comment">/* The keyspace for this DB */</span><br>    dict *expires; <span class="hljs-comment">/* Timeout of keys with a timeout set */</span><br>    ......<br>&#125; redisDb;<br></code></pre></td></tr></table></figure><ol start="3"><li>Redis有最大内存淘汰机制(maxmemory-policy)，如果键值个数过多，那么可能逐出的就会更多，也就意味段时间内有大量的删除操作，甚至会造成Redis段时间不可用</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis 缓存设计思想</title>
    <link href="/2024/08/30/MyBatis%20%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    <url>/2024/08/30/MyBatis%20%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<p>缓存本质其实就是一个 Map，MyBatis 的缓存最基本的实现是 PerpetualCache，内部使用了 HashMap 来保存数据</p><p>缓存一般还有额外的功能比如淘汰策略，最大时长等，如何扩展这些功能？</p><p>扩展类的功能有 2 种，继承和组合，但是 MyBatis 提供了很多功能并且有的是动态组合的，比如容量上限 512，淘汰策略 LRU… 如果是集成的话，那要把所有排列组合都实现一遍，会导致类爆炸</p><p>MyBatis 采用了<strong>装饰器模式</strong>，采用<strong>组合</strong>的方式扩展新功能</p><blockquote><p>装饰器模式使用的是组合方式，相较于继承这种静态的扩展方式，装饰器模式可以在运行时根据系统状态，动态决定为一个实现类添加哪些扩展功能</p></blockquote><p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20241110110554.png"></p><ul><li>Component 接口：已有的业务接口，是<strong>整个功能的核心抽象</strong>，定义了 Decorator 和 ComponentImpl 这些实现类的核心行为<ul><li>JDK 中的 IO 流体系就使用了装饰器模式，其中的 InputStream 接口就扮演了 Component 接口的角色</li></ul></li><li>ComponentImpl 实现类：实现了上面介绍的 Component 接口，其中<strong>实现了 Component 接口最基础、最核心的功能</strong>，也就是被装饰的、原始的基础类<ul><li>JDK IO 流体系之中的 FileInputStream 就扮演了 ComponentImpl 的角色，它实现了读取文件的基本能力，例如，读取单个 byte、读取 byte[] 数组</li></ul></li><li>Decorator 抽象类：所有装饰器的父类，实现了 Component 接口，<strong>其核心不是提供新的扩展能力，而是封装一个 Component 类型的字段，也就是被装饰的目标对象</strong><ul><li>这里的被装饰对象可以是ComponentImpl 对象，也可以是 Decorator 实现类的对象</li><li>下面DecoratorImpl1 装饰了 DecoratorImpl2，DecoratorImpl2 装饰了 ComponentImpl，经过了这一系列装饰之后得到的 Component 对象，除了具有 ComponentImpl 的基础能力之外，还拥有了 DecoratorImpl1 和 DecoratorImpl2 的扩展能力</li></ul></li></ul><p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20241110111022.png"></p><p>MyBatis 中<strong>除了 PerpetualCache 之外的其他所有 Cache 接口实现类，都是装饰器实现</strong></p><blockquote><p>Spring 中的 IoC容器，它有各种各样的实现类，完全就是通过继承进行功能的扩展，与 MyBatis 的实现思路截然不同，为什么?</p></blockquote><p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20241110112245.png"></p><p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20241110112525.png"></p><p>对比MyBatis 的 Cache 继承体系图和 BeanFactory 的继承体系图装饰器模式可以动态、灵活的扩展新的功能，但是它有一个问题，就是客户端的可控程度比较低。</p><p>无论缓存扩展了哪些功能，对于客户端来说，暴露的都只是一个 Cache 接口，客户端并不知道此时缓存已经具有了哪些能力，甚至如果客户端对内部实现不了解，自己扩展了两个互斥的包装器，还会引起系统异常的风险。 </p><p>对于 MyBatis 来说，它内置的缓存功能在绝大部分场景下都是不需要客户度自行开发和扩展的，客户端只需要指定我需要缓存的哪些功能就好。在这个前提，MyBatis 可以放心地使用装饰器模式。 </p><p>而 Spring 则不同，它提供的 BeanFactory、ApplicationContext 这一整套 IoC 容器，是直接暴露给客户端使用的，有时还会基于已有的容器进行二次开发。这样就需要客户端有较强的把控能力，需要明确的知道我当前使用的是哪种 BeanFactory，它具有哪些能力。</p><p>如果像 MyBatis 一样，只对外暴露一个 BeanFactory 接口，那么客户端进行二次开发就十分不友好了。 </p><p>总结起来，造成 MyBatis 和 Spring 这种扩展思路的差异的最重要原因之一，就是 MyBatis 的 Cache 模块需要降低用户学习成本，直接指定需要增加的功能即可；而 Spring 的 IoC 容器则是为客户端的使用和二次开发提供了更大的空间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis 日志设计思想</title>
    <link href="/2024/08/23/MyBatis%20%E6%97%A5%E5%BF%97%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    <url>/2024/08/23/MyBatis%20%E6%97%A5%E5%BF%97%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<p>整体架构用了门面模式，对外暴露 SqlSession 接口</p><p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20241110104348.png"></p><p>日志模块，采用了适配器模式</p><blockquote><p>如果需要接入多个第三方 SDK 来满足自己的业务需求，但是 SDK 的接口定义与你的业务不兼容，又不能修改第三方 SDK 的代码，可以用适配器设计模式解决</p></blockquote><p>MyBatis 定义了自己 Log 接口，为大部分主流日志框架都实现了 Adapter 适配器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Log</span> &#123;<br><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDebugEnabled</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTraceEnabled</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">error</span><span class="hljs-params">(String s, Throwable e)</span>;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">error</span><span class="hljs-params">(String s)</span>;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String s)</span>;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String s)</span>;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">warn</span><span class="hljs-params">(String s)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>定义了四种 Log 级别，以 Slf4j 实现为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Slf4jImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Log</span> &#123;<br><br>  <span class="hljs-keyword">private</span> Log log;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Slf4jImpl</span><span class="hljs-params">(String clazz)</span> &#123;<br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(clazz);<br><br>    <span class="hljs-keyword">if</span> (logger <span class="hljs-keyword">instanceof</span> LocationAwareLogger) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// check for slf4j &gt;= 1.6 method signature</span><br>        logger.getClass().getMethod(<span class="hljs-string">&quot;log&quot;</span>, Marker.class, String.class, <span class="hljs-type">int</span>.class, String.class, Object[].class,<br>            Throwable.class);<br>        log = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Slf4jLocationAwareLoggerImpl</span>((LocationAwareLogger) logger);<br>        <span class="hljs-keyword">return</span>;<br>      &#125; <span class="hljs-keyword">catch</span> (SecurityException | NoSuchMethodException e) &#123;<br>        <span class="hljs-comment">// fail-back to Slf4jLoggerImpl</span><br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Logger is not LocationAwareLogger or slf4j version &lt; 1.6</span><br>    log = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Slf4jLoggerImpl</span>(logger);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDebugEnabled</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> log.isDebugEnabled();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTraceEnabled</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> log.isTraceEnabled();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">error</span><span class="hljs-params">(String s, Throwable e)</span> &#123;<br>    log.error(s, e);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">error</span><span class="hljs-params">(String s)</span> &#123;<br>    log.error(s);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String s)</span> &#123;<br>    log.debug(s);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String s)</span> &#123;<br>    log.trace(s);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">warn</span><span class="hljs-params">(String s)</span> &#123;<br>    log.warn(s);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>同时定义了一个 LogFactory 类，日志的实例是从这里获取的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogFactory</span> &#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Marker to be used by logging implementations that support markers.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MARKER</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MYBATIS&quot;</span>;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Constructor&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Log</span>&gt; logConstructor;<br><br>  <span class="hljs-keyword">static</span> &#123;<br>    tryImplementation(LogFactory::useSlf4jLogging);<br>    tryImplementation(LogFactory::useCommonsLogging);<br>    tryImplementation(LogFactory::useLog4J2Logging);<br>    tryImplementation(LogFactory::useLog4JLogging);<br>    tryImplementation(LogFactory::useJdkLogging);<br>    tryImplementation(LogFactory::useNoLogging);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">LogFactory</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// disable construction</span><br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过静态代码块定义了类加载的顺序，slf4j -&gt; commons-logging -&gt; log4j2 -&gt; log4j -&gt; jdk-logging -&gt; no-logging</p><p>如果项目中有对应的依赖，则通过反射加载对应的日志接口</p><p>By the way，MyBatis 通过JDK 动态代理记录数据库连接，预编译语句，和结果记录，分别是 ConnectionLogger、PreparedStatementLogger 和 ResultSetLogger</p>]]></content>
    
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadPoolExecutor</title>
    <link href="/2024/08/20/ThreadPoolExecutor/"/>
    <url>/2024/08/20/ThreadPoolExecutor/</url>
    
    <content type="html"><![CDATA[<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>线程池对象，如果里面添加了任务，如果不手动调用 <code>shutdown</code> 方法，那么这个对象永远不会被 GC</p><p>首先看一下 <code>ThreadPoolExecutor</code> 的源码结构</p><p><code>ThreadPoolExecutor</code> 里面有一个内部类 <code>Worker</code> 这个内部类实现了 <code>Runnable</code> 接口</p><p>这个 <code>Worker</code> 类里有一个 <code>runWorker</code> 方法，是保证线程不断运行的原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>    w.firstTask = <span class="hljs-literal">null</span>;<br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>            w.lock();<br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                beforeExecute(wt, task);<br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-literal">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 最外层的 while 循环不断调用 <code>getTask()</code> 方法从队列中取任务，如果取不到，就属于异常情况，把 <code>completedAbruptly</code> 设置为 false，进入 <code>processWorkerExit</code> 方法</p>]]></content>
    
    
    
    <tags>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一致性哈希</title>
    <link href="/2024/08/16/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    <url>/2024/08/16/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<p>一致性哈希问题是为了解决请求负载均衡的</p><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><p>在多节点分布式系统中，如何有效分配客户端请求以实现负载均衡</p><ol><li><p>轮询算法</p></li><li><p>加权轮询算法</p></li><li><p>哈希算法</p><ul><li>上面两中对于数据分片就不适用了，比如缓存的 key 分布在不同的节点上，通过哈希函数和取模运算可以将请求映射到特定节点</li></ul></li><li><p>一致性哈希</p></li></ol><h2 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h2><p>普通哈希算法存在问题，当节点数增加的时候，需要重新计算映射关系，也要迁移数据</p><p>比如一开始有 3 台机器，模 3，之后变成 4 台，需要做数据迁移并且重新计算映射关系</p><p>一致性哈希也是用了取模，但是与普通哈希不一样，普通哈希对节点数进行取模，一致性哈希是对 <code>2^32</code> 进行取模</p><p>一致性哈希是将【存储节点】和【数据】都映射到一个首尾相连的哈希环上，如果增加或移除一个节点，仅<strong>影响该节点在哈希环上顺时针相邻的后继结点</strong>（因为他的寻址规则是把数据哈希之后顺时针找到第一个存储节点），其他数据不会收到影响</p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240906215850.png"  style="zoom: 50%;" /><p>但是<strong>一致性哈希算法不能均匀分布节点</strong>，会出现大量请求都集中在一个节点的情况，这种情况下进行容灾或备份的时候，容易出现雪崩</p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240819101745.png"  style="zoom: 30%;" /><p>为了解决一致性哈希不能均匀分布节点的问题，需要引入虚拟节点，对一个真实节点做多个副本，再将虚拟节点映射到实际节点，有两层映射关系</p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240819101754.png"  style="zoom: 30%;" />]]></content>
    
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CountDownLatch</title>
    <link href="/2024/08/10/CountDownLatch/"/>
    <url>/2024/08/10/CountDownLatch/</url>
    
    <content type="html"><![CDATA[<p><code>CountDownLatch</code> 类存在一个内部类 <code>Sync</code> 继承自 <code>AbstractQueueSynchronizer</code> </p><p>所以 <code>CountDownLatch</code> 也是基于 AQS 实现的，其中 state 表示前面有几个线程需要等待</p><h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h2><h3 id="内部类结构"><a href="#内部类结构" class="headerlink" title="内部类结构"></a>内部类结构</h3><p>类中只有一个成员变量 <code>Sync</code> 这个类继承了 <code>AbstractQueueSynchronizer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatch</span> &#123;<br>    <span class="hljs-comment">// 同步队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h3><p>调用了 <code>Sync</code> 的构造方法, <code>Sync</code> 又调用了父类 AQS 的方法, 设置了 state 值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDownLatch</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br><span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;count &lt; 0&quot;</span>);<br><span class="hljs-built_in">this</span>.sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>(count);<br>&#125;<br><span class="hljs-comment">// 其中 Sync 的构造函数调用了父类 AQS 的方法, 设置了 AQS 中的 state 值</span><br>Sync(<span class="hljs-type">int</span> count) &#123;<br>setState(count);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="await-函数"><a href="#await-函数" class="headerlink" title="await 函数"></a>await 函数</h3><p>此函数将会使当前线程在锁存器倒计数至 0 之前一直等待, 除非线程被中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="countDown-函数"><a href="#countDown-函数" class="headerlink" title="countDown 函数"></a>countDown 函数</h3><p>此函数将递减锁存器的计数, 如果计数达到 0, 则释放所有等待线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123;<br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        executorService.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; is running...&quot;</span>);<br>                <span class="hljs-comment">// 每个线程睡 1s</span><br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-comment">// ignore</span><br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 休眠完之后 countDownLatch - 1</span><br>                countDownLatch.countDown();<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-comment">// 只有 countDownLatch 减到 0 的时候才会停止阻塞</span><br>    countDownLatch.await();<br>    executorService.shutdown();<br>    System.out.println(<span class="hljs-string">&quot;end...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>记得最后要调用 <code>shutdown()</code> 否则线程永远不会结束</p><p>因为线程池的线程处于 waiting 状态，他们作为 GC Root 不会被回收</p>]]></content>
    
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redisson 延迟队列</title>
    <link href="/2024/07/30/Redisson%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/"/>
    <url>/2024/07/30/Redisson%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="Redisson-延迟队列"><a href="#Redisson-延迟队列" class="headerlink" title="Redisson 延迟队列"></a>Redisson 延迟队列</h2><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p>底层用 3 个队列实现</p><ol><li>消息延迟队列，Zset 类型，按照过期时间顺序存放消息列表</li><li>消息顺序队列，List 类型，按照添加顺序存放消息列表</li><li>消息目标队列，List 类型，存放到期的消息，供消费者获取</li></ol><p>消息来的时候先插入【消息延迟队列】和【消息顺序队列】</p><p>最后消费者在【消息目标队列】进行消费的，消费者只需要阻塞等待【消息目标队列】即可</p><h3 id="消息移动"><a href="#消息移动" class="headerlink" title="消息移动"></a>消息移动</h3><p>在初始化延迟队列的时候，会定时从【消息延迟队列】查询到最新到期时间，定时把【消息延迟队列】的消息移动到【消息目标队列】</p><p>如果【消息延迟队列】是空的，就不再定时差，而是等待发布订阅消息提醒，再定时把【消息延迟队列】的消息移动到【消息目标队列】</p><h3 id="发送和获取延迟消息"><a href="#发送和获取延迟消息" class="headerlink" title="发送和获取延迟消息"></a>发送和获取延迟消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 生产者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produce</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">queuename</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delay-queue&quot;</span>;<br>    RBlockingQueue&lt;String&gt; blockingQueue = redissonClient.getBlockingQueue(queuename);<br>    RDelayedQueue&lt;String&gt; delayedQueue = redissonClient.getDelayedQueue(blockingQueue);<br>    delayedQueue.offer(<span class="hljs-string">&quot;测试延迟消息&quot;</span>, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>&#125;<br><br><span class="hljs-comment">// 消费者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">queuename</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delay-queue&quot;</span>;<br>    RBlockingQueue&lt;String&gt; blockingQueue = redissonClient.getBlockingQueue(queuename);<br>    RDelayedQueue&lt;String&gt; delayedQueue = redissonClient.getDelayedQueue(blockingQueue);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> blockingQueue.take();<br>    <span class="hljs-comment">//收到消息进行处理...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="初始化延迟队列"><a href="#初始化延迟队列" class="headerlink" title="初始化延迟队列"></a>初始化延迟队列</h3><p>主要是调用了 <code>QueueTransferTask</code> 的 <code>start()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">RTopic</span> <span class="hljs-variable">schedulerTopic</span> <span class="hljs-operator">=</span> getTopic();<br>        statusListenerId = schedulerTopic.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BaseStatusListener</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSubscribe</span><span class="hljs-params">(String channel)</span> &#123;<br>                pushTask();<br>            &#125;<br>        &#125;);<br>        <br>        messageListenerId = schedulerTopic.addListener(Long.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListener</span>&lt;Long&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(CharSequence channel, Long startTime)</span> &#123;<br>                scheduleTask(startTime);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>队列有新的消费者订阅时，调用 <code>pushTask()</code> 方法，把消息发送出去</p><p>指定主题有新消息时，调用 <code>scheduleTask(startTime)</code> 方法，会定时调用 <code>pushTask()</code> 方法，把消息发送出去</p><h3 id="为什么在消费端也要初始化延迟队列？"><a href="#为什么在消费端也要初始化延迟队列？" class="headerlink" title="为什么在消费端也要初始化延迟队列？"></a>为什么在消费端也要初始化延迟队列？</h3><p>接收消息的时候明明用不到 <code>delayedQueue</code> 为什么还要加？</p><ul><li>初始化延迟队列的作用是会定时把【消息延迟队列】的到期数据移动到【消息目标队列】</li><li>如果发送方发送了延迟消息，但在到期之前下线了，接收方就接收不到了</li><li>所以是为了避免一部分数据丢失问题</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置中心的长轮询</title>
    <link href="/2024/07/23/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E7%9A%84%E9%95%BF%E8%BD%AE%E8%AF%A2/"/>
    <url>/2024/07/23/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E7%9A%84%E9%95%BF%E8%BD%AE%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="配置中心的长轮询"><a href="#配置中心的长轮询" class="headerlink" title="配置中心的长轮询"></a>配置中心的长轮询</h2><p>配置中心是为了解决传统静态配置修改重启应用的问题，Nacos 和 Apollo 都是通过长轮询来实现动态推送的，而不是长连接</p><h2 id="推拉模式"><a href="#推拉模式" class="headerlink" title="推拉模式"></a>推拉模式</h2><p>数据交互有两种模式：【推模式 push】和【拉模式 pull】</p><ul><li>推模式是客户端和服务器建立好长链接，服务器的数据推送到客户端<ul><li>优点，及时，一旦有数据变更，客户端立马能感知到</li><li>缺点，不知道客户端消费能力，可能导致数据堆积</li></ul></li><li>拉模式是客户端主动向服务器发起请求</li></ul><h2 id="长轮询与轮询"><a href="#长轮询与轮询" class="headerlink" title="长轮询与轮询"></a>长轮询与轮询</h2><p>长轮询和轮询都是拉模式实现的</p><ul><li>轮询是指不管服务数据有无更新，客户端每隔顶长时间去请求一次数据</li></ul><p>如果配置中心用【轮询】推送，会有以下问题</p><ul><li>推送延迟，客户端每隔 5s 拉取一次配置，如果配置变更发生在第 6s，推送的延迟就是 4s</li><li>服务端压力，因为配置一般不会发生变化，频繁轮询会造成服务端压力</li><li>降低轮询间隔，延迟降低，压力增加，反之亦然</li></ul><p>【长轮询】是客户端发起请求，如果服务端数据没有变更，会 hold 住请求，直到服务端数据发生变化，或者等待一定时间超时返回。客户端再次发起下次请求</p><ul><li>服务端数据发生变更之后，长轮询结束，立刻返回响应</li><li>长轮询间隔一般很长 30s 60s，并且服务端 hold 住连接，不会消耗太多资源</li></ul><p>为什么要等待一定时间超时，而不是一直 hold 请求？</p><ul><li>连接稳定性，长轮询本质也是 TCP 连接，仅仅依靠 TCP 层很难保证可用性</li><li>用户可能随时新增配置监听，所以要在下一次长轮询中加入</li></ul><h2 id="配置中心长轮询设计"><a href="#配置中心长轮询设计" class="headerlink" title="配置中心长轮询设计"></a>配置中心长轮询设计</h2><ol><li>客户端发起长轮询，客户端发起一个 http 请求，包含配置中心地址，以及监听的 dataId（定位配置的唯一键）</li><li>服务端监听数据变化，服务端维护 dataId 和长轮询映射关系，如果配置发生变化，服务端会找到对应的连接，在响应体里填入更新的配置内容，如果超时则返回 304</li><li>客户端接收响应，看是 200 还是 304</li></ol><p>配置中心在实现长轮询的时候不应该阻塞 Tomcat 业务线程，所以一般采用异步响应方式实现</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 配置监听接入点</span><br><span class="hljs-meta">@RequestMapping(&quot;/listener&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addListener</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">dataId</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;dataId&quot;</span>);<br><br>    <span class="hljs-comment">// 开启异步</span><br>    <span class="hljs-type">AsyncContext</span> <span class="hljs-variable">asyncContext</span> <span class="hljs-operator">=</span> request.startAsync(request, response);<br>    <span class="hljs-type">AsyncTask</span> <span class="hljs-variable">asyncTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncTask</span>(asyncContext, <span class="hljs-literal">true</span>);<br><br>    <span class="hljs-comment">// 维护 dataId 和异步请求上下文的关联</span><br>    dataIdContext.put(dataId, asyncTask);<br><br>    <span class="hljs-comment">// 启动定时器，30s 后写入 304 响应</span><br>    timeoutChecker.schedule(() -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (asyncTask.isTimeout()) &#123;<br>            dataIdContext.remove(dataId, asyncTask);<br>            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);<br>            asyncContext.complete();<br>        &#125;<br>    &#125;, <span class="hljs-number">30000</span>, TimeUnit.MILLISECONDS);<br>&#125;<br><br> <span class="hljs-comment">// 配置发布接入点</span><br><span class="hljs-meta">@RequestMapping(&quot;/publishConfig&quot;)</span><br><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">publishConfig</span><span class="hljs-params">(String dataId, String configInfo)</span> &#123;<br>    log.info(<span class="hljs-string">&quot;publish configInfo dataId: [&#123;&#125;], configInfo: &#123;&#125;&quot;</span>, dataId, configInfo);<br>    Collection&lt;AsyncTask&gt; asyncTasks = dataIdContext.removeAll(dataId);<br>    <span class="hljs-keyword">for</span> (AsyncTask asyncTask : asyncTasks) &#123;<br>        asyncTask.setTimeout(<span class="hljs-literal">false</span>);<br>        <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> (HttpServletResponse)asyncTask.getAsyncContext().getResponse();<br>        response.setStatus(HttpServletResponse.SC_OK);<br>        response.getWriter().println(configInfo);<br>        asyncTask.getAsyncContext().complete();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>长轮询请求 <code>/listener</code> 的时候设置定时器，30s 后写入 304 响应</p><p>如果在其中配置变了 <code>/publishConfig</code> 写入变更，并且取消定时任务</p>]]></content>
    
    
    
    <tags>
      
      <tag>配置中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-step02</title>
    <link href="/2024/07/22/MyBatis-step02/"/>
    <url>/2024/07/22/MyBatis-step02/</url>
    
    <content type="html"><![CDATA[<p>这是一个流程，</p><ul><li>通过 <code>SqlSessionFactory</code> 开启一个 <code>SqlSession</code> </li><li><code>SqlSession</code> 里有成员变量 <code>MapperRegistry</code> </li><li><code>MapperRegistry</code> 里面通过包路径扫描，得到了一个 map</li><li>这个 map 封装了接口，跟它的代理类工厂</li><li>可以通过 get 的方式获得代理类工厂，用工厂的静态方法 new 出来一个代理对象</li><li><strong>使用工厂模式可以屏蔽创建细节，延迟创建过程</strong></li></ul><p>![image-20240818141349865](&#x2F;Users&#x2F;sudong&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240818141349865.png)</p><p>目前这个接口中对于数据库的操作仅仅只提供了 selectOne，后续还会有相应其他方法的定义</p><h2 id="目录结构和代码"><a href="#目录结构和代码" class="headerlink" title="目录结构和代码"></a>目录结构和代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">mybatis-step-<span class="hljs-number">02</span><br>└── src<br>    ├── main<br>    │   └── java<br>    │       └── cn.bugstack.mybatis<br>    │           ├── binding<br>    │           │   ├── MapperProxy.java<br>    │           │   ├── MapperProxyFactory.java<br>    │           │   └── MapperRegistry.java<br>    │           └── session<br>    │               ├── defaults<br>    │               │   ├── DefaultSqlSession.java<br>    │               │   └── DefaultSqlSessionFactory.java<br>    │               ├── SqlSession.java<br>    │               └── SqlSessionFactory.java<br>    └── test<br>        └── java<br>            └── cn.bugstack.mybatis.test.dao<br>                ├── dao<br>                │   ├── ISchoolDao.java<br>                │   └── IUserDao.java<br>                └── ApiTest.java<br><br></code></pre></td></tr></table></figure><p>MapperProxy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperProxy</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span>, Serializable &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">6424540398559729838L</span>;<br><br>    <span class="hljs-comment">// 所有的数据库操作语句都是通过 接口名称+方法名称作为 key，操作逻辑作为 value</span><br>    <span class="hljs-comment">// 在反射中调用就是获取对应的操作直接执行并返回结果</span><br>    <span class="hljs-keyword">private</span> SqlSession sqlSession;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;T&gt; mapperInterface;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MapperProxy</span><span class="hljs-params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sqlSession = sqlSession;<br>        <span class="hljs-built_in">this</span>.mapperInterface = mapperInterface;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// Object 类里的方法不代理</span><br>        <span class="hljs-keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;<br>            <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-built_in">this</span>, args);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你的被代理了！&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>MapperProxyFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperProxyFactory</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;T&gt; mapperInterface;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MapperProxyFactory</span><span class="hljs-params">(Class&lt;T&gt; mapperInterface)</span> &#123;<br>        <span class="hljs-built_in">this</span>.mapperInterface = mapperInterface;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">newInstance</span><span class="hljs-params">(SqlSession sqlSession)</span> &#123;<br>        <span class="hljs-keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperProxy</span>&lt;&gt;(sqlSession, mapperInterface);<br>        <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;mapperInterface&#125;, mapperProxy);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>MapperRegistry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperRegistry</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将已添加的映射器代理加入到 HashMap</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据类型，返回工厂，再用工厂生成代理对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sqlSession</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;<br>        <span class="hljs-keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);<br>        <span class="hljs-keyword">if</span> (mapperProxyFactory == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Type &quot;</span> + type + <span class="hljs-string">&quot; is not known to the MapperRegistry.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> mapperProxyFactory.newInstance(sqlSession);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 把 type 类型的添加到 knownMappers 这个 map 里</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">addMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> &#123;<br>        <span class="hljs-comment">/* Mapper 必须是接口才会注册 */</span><br>        <span class="hljs-keyword">if</span> (type.isInterface()) &#123;<br>            <span class="hljs-keyword">if</span> (hasMapper(type)) &#123;<br>                <span class="hljs-comment">// 如果重复添加了，报错</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Type &quot;</span> + type + <span class="hljs-string">&quot; is already known to the MapperRegistry.&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 注册映射器代理工厂</span><br>            knownMappers.put(type, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperProxyFactory</span>&lt;&gt;(type));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否存在过</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> &#123;<br>        <span class="hljs-keyword">return</span> knownMappers.containsKey(type);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 把包下的所有的类添加到 knownMappers 里</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> packageName</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addMappers</span><span class="hljs-params">(String packageName)</span> &#123;<br>        <span class="hljs-comment">// 用于扫描指定包名下的所有类，并返回这些类的集合</span><br>        Set&lt;Class&lt;?&gt;&gt; mapperSet = ClassScanner.scanPackage(packageName);<br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; mapperClass : mapperSet) &#123;<br>            addMapper(mapperClass);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>DefaultSqlSession</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultSqlSession</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SqlSession</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 映射器注册机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MapperRegistry mapperRegistry;<br><br>    DefaultSqlSession(MapperRegistry mapperRegistry)&#123;<br>        <span class="hljs-built_in">this</span>.mapperRegistry = mapperRegistry;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">selectOne</span><span class="hljs-params">(String statement)</span> &#123;<br>        <span class="hljs-keyword">return</span> (T) (<span class="hljs-string">&quot;你被代理了！&quot;</span> + <span class="hljs-string">&quot;方法：&quot;</span> + statement);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">selectOne</span><span class="hljs-params">(String statement, Object parameter)</span> &#123;<br>        <span class="hljs-keyword">return</span> (T) (<span class="hljs-string">&quot;你被代理了！&quot;</span> + <span class="hljs-string">&quot;方法：&quot;</span> + statement + <span class="hljs-string">&quot; 入参：&quot;</span> + parameter);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapperRegistry.getMapper(type, <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>DefaultSqlSessionFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultSqlSessionFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SqlSessionFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MapperRegistry mapperRegistry;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultSqlSessionFactory</span><span class="hljs-params">(MapperRegistry mapperRegistry)</span> &#123;<br>        <span class="hljs-built_in">this</span>.mapperRegistry = mapperRegistry;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SqlSession <span class="hljs-title function_">openSession</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultSqlSession</span>(mapperRegistry);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>SqlSession</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SqlSession</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Retrieve a single row mapped from the statement key</span><br><span class="hljs-comment">     * 根据指定的SqlID获取一条记录的封装对象</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;       the returned object type 封装之后的对象类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> statement sqlID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Mapped object 封装之后的对象</span><br><span class="hljs-comment">     */</span><br>    &lt;T&gt; T <span class="hljs-title function_">selectOne</span><span class="hljs-params">(String statement)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Retrieve a single row mapped from the statement key and parameter.</span><br><span class="hljs-comment">     * 根据指定的SqlID获取一条记录的封装对象，只不过这个方法容许我们可以给sql传递一些参数</span><br><span class="hljs-comment">     * 一般在实际使用中，这个参数传递的是pojo，或者Map或者ImmutableMap</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;       the returned object type</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> statement Unique identifier matching the statement to use.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> parameter A parameter object to pass to the statement.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Mapped object</span><br><span class="hljs-comment">     */</span><br>    &lt;T&gt; T <span class="hljs-title function_">selectOne</span><span class="hljs-params">(String statement, Object parameter)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Retrieves a mapper.</span><br><span class="hljs-comment">     * 得到映射器，这个巧妙的使用了泛型，使得类型安全</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;  the mapper type</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type Mapper interface class</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a mapper bound to this SqlSession</span><br><span class="hljs-comment">     */</span><br>    &lt;T&gt; T <span class="hljs-title function_">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>SqlSessionFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SqlSessionFactory</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打开一个 session</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> SqlSession</span><br><span class="hljs-comment">     */</span><br>    SqlSession <span class="hljs-title function_">openSession</span><span class="hljs-params">()</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>Dao 层接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISchoolDao</span> &#123;<br><br>    String <span class="hljs-title function_">querySchoolName</span><span class="hljs-params">(String uId)</span>;<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserDao</span> &#123;<br><br>    String <span class="hljs-title function_">queryUserName</span><span class="hljs-params">(String uId)</span>;<br><br>    Integer <span class="hljs-title function_">queryUserAge</span><span class="hljs-params">(String uId)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_MapperProxyFactory</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1. 注册 Mapper</span><br>    <span class="hljs-type">MapperRegistry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperRegistry</span>();<br>    registry.addMappers(<span class="hljs-string">&quot;cn.bugstack.mybatis.test.dao&quot;</span>);<br><br>    <span class="hljs-comment">// 2. 从 SqlSession 工厂获取 Session</span><br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultSqlSessionFactory</span>(registry);<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br><br>    <span class="hljs-comment">// 3. 获取映射器对象</span><br>    <span class="hljs-type">IUserDao</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> sqlSession.getMapper(IUserDao.class);<br><br>    <span class="hljs-comment">// 4. 测试验证</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> userDao.queryUserName(<span class="hljs-string">&quot;10001&quot;</span>);<br>    logger.info(<span class="hljs-string">&quot;测试结果：&#123;&#125;&quot;</span>, res);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Retrieves a mapper.</span><br><span class="hljs-comment"> * 得到映射器，这个巧妙的使用了泛型，使得类型安全</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;  the mapper type</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> type Mapper interface class</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> a mapper bound to this SqlSession</span><br><span class="hljs-comment"> */</span><br>&lt;T&gt; T <span class="hljs-title function_">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span>;<br></code></pre></td></tr></table></figure><p>如何理解 “巧妙地使用了泛型，使得类型安全”</p><p>在这个方法里，<code>&lt;T&gt;</code> 表示这是一个泛型方法，其中传入的参数是 <code>Class&lt;T&gt;</code> 这说明参数的类型与返回值的类型应该相等</p><p>类型安全意味着编译器会在编译时进行类型检查，以防止类型错误，通过泛型，<code>getMapper</code> 方法能够确保返回的对象类型与调用者期望的类型一致，避免了强制类型转换</p><p>在调用的时候可以这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSesson.getMapepr(UserMapper.class);<br></code></pre></td></tr></table></figure><p>与非泛型方法对比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getMapper</span><span class="hljs-params">(Class&lt;?&gt; type)</span>;<br></code></pre></td></tr></table></figure><p>在调用的时候需要强制类型转换，编译器无法验证类型转换是否正确，可能在运行时抛出 <code>ClassCastException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> (UserMapper) sqlSession.getMapper(UserMapper.class);<br></code></pre></td></tr></table></figure><p>本篇文章是在小傅哥的基础上，添加了自己的理解写下的<br>小傅哥博客：<a href="https://bugstack.cn/">https://bugstack.cn</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-step01</title>
    <link href="/2024/07/21/MyBatis-step01/"/>
    <url>/2024/07/21/MyBatis-step01/</url>
    
    <content type="html"><![CDATA[<h2 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h2><p><code>InvocationHandler</code> 接口是 Java 动态代理的核心部分，它里面有一个方法 <code>invoke</code> </p><p>当使用动态代理创建一个代理对象时，所有对代理对象的方法调用都会被路由到实现了 <code>InvocationHandler</code> 接口的 <code>invoke</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperProxy</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span>, Serializable &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">6424540398559729838L</span>;<br>    <span class="hljs-comment">// 此处省略一些，目的是为了结构更清晰 ...</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// Object 类里的方法不代理</span><br>        <span class="hljs-keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;<br>            <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-built_in">this</span>, args);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你的被代理了！&quot;</span> + sqlSession.get(mapperInterface.getName() + <span class="hljs-string">&quot;.&quot;</span> + method.getName());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果创建了一个 <code>MapperProxy</code> 代理对象，那么就会调用 <code>invoke</code> 方法</p><p><code>invoke</code> 方法里，它做了一些判断，对于 <code>Object</code> 类里的方法，不进行代理</p><h2 id="Proxy-newProxyInstanse"><a href="#Proxy-newProxyInstanse" class="headerlink" title="Proxy.newProxyInstanse"></a>Proxy.newProxyInstanse</h2><p>是 Java 中用于创建动态代理对象的一个静态方法，参数列表如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span><br>        <span class="hljs-keyword">throws</span> IllegalArgumentException<br></code></pre></td></tr></table></figure><ul><li><code>ClassLoader loade</code>r：指定类加载器，通常传入<strong>目标对象的类加载器</strong></li><li><code>Class&lt;?&gt;[] interfaces</code> ：接口数组，代理类会实现这些接口，<strong>这些接口决定了代理类可以调用的方法</strong></li><li><code>InvocationHandler h</code> ： 一个接口，代理对象上的所有方法调用都会委托给它的 <code>invoke</code> 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperProxyFactory</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;T&gt; mapperInterface;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MapperProxyFactory</span><span class="hljs-params">(Class&lt;T&gt; mapperInterface)</span> &#123;<br>        <span class="hljs-built_in">this</span>.mapperInterface = mapperInterface;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">newInstance</span><span class="hljs-params">(Map&lt;String, String&gt; sqlSession)</span> &#123;<br>        <span class="hljs-keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperProxy</span>&lt;&gt;(sqlSession, mapperInterface);<br>        <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;mapperInterface&#125;, mapperProxy);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个工厂类需要传入一个接口 <code>mapperInterface</code>，这个接口就是要代理的接口</p><p>调用 <code>Proxy.newProxyInstance</code> 方法，传入类加载器，要实现的接口，实现了 <code>InvovationHandler</code> 的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">mybatis-step-<span class="hljs-number">01</span><br>└── src<br>    ├── main<br>    │   └── java<br>    │       └── cn.bugstack.mybatis.binding<br>    │           ├── MapperProxy.java<br>    │           └── MapperProxyFactory.java<br>    └── test<br>        └── java<br>            └── cn.bugstack.mybatis.test.dao<br>                ├── dao<br>                │   └── IUserDao.java<br>                └── ApiTest.java<br></code></pre></td></tr></table></figure><p>MapperProxy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperProxy</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span>, Serializable &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">6424540398559729838L</span>;<br><br>    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; sqlSession;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;T&gt; mapperInterface;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MapperProxy</span><span class="hljs-params">(Map&lt;String, String&gt; sqlSession, Class&lt;T&gt; mapperInterface)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sqlSession = sqlSession;<br>        <span class="hljs-built_in">this</span>.mapperInterface = mapperInterface;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;<br>            <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-built_in">this</span>, args);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你的被代理了！&quot;</span> + sqlSession.get(mapperInterface.getName() + <span class="hljs-string">&quot;.&quot;</span> + method.getName());<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>MapperProxyFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperProxyFactory</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;T&gt; mapperInterface;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MapperProxyFactory</span><span class="hljs-params">(Class&lt;T&gt; mapperInterface)</span> &#123;<br>        <span class="hljs-built_in">this</span>.mapperInterface = mapperInterface;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">newInstance</span><span class="hljs-params">(Map&lt;String, String&gt; sqlSession)</span> &#123;<br>        <span class="hljs-keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperProxy</span>&lt;&gt;(sqlSession, mapperInterface);<br>        <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;mapperInterface&#125;, mapperProxy);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>IUserDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserDao</span> &#123;<br><br>    String <span class="hljs-title function_">queryUserName</span><span class="hljs-params">(String uId)</span>;<br><br>    Integer <span class="hljs-title function_">queryUserAge</span><span class="hljs-params">(String uId)</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>测试用例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_MapperProxyFactory</span><span class="hljs-params">()</span> &#123;<br>    MapperProxyFactory&lt;IUserDao&gt; factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperProxyFactory</span>&lt;&gt;(IUserDao.class);<br>    Map&lt;String, String&gt; sqlSession = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    sqlSession.put(<span class="hljs-string">&quot;cn.bugstack.mybatis.test.dao.IUserDao.queryUserName&quot;</span>, <span class="hljs-string">&quot;模拟执行 Mapper.xml 中 SQL 语句的操作：查询用户姓名&quot;</span>);<br>    sqlSession.put(<span class="hljs-string">&quot;cn.bugstack.mybatis.test.dao.IUserDao.queryUserAge&quot;</span>, <span class="hljs-string">&quot;模拟执行 Mapper.xml 中 SQL 语句的操作：查询用户年龄&quot;</span>);<br>    <span class="hljs-type">IUserDao</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> factory.newInstance(sqlSession);<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> userDao.queryUserName(<span class="hljs-string">&quot;10001&quot;</span>);<br>    logger.info(<span class="hljs-string">&quot;测试结果：&#123;&#125;&quot;</span>, res);<br>&#125;<br><br><span class="hljs-comment">// cn.bugstack.mybatis.test.ApiTest - 测试结果：你的被代理了！模拟执行 Mapper.xml 中 SQL 语句的操作：查询用户姓名</span><br></code></pre></td></tr></table></figure><p>本篇文章是在小傅哥的基础上，添加了自己的理解写下的<br>小傅哥博客：<a href="https://bugstack.cn/">https://bugstack.cn</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安全点 SafePoint</title>
    <link href="/2024/07/17/%E5%AE%89%E5%85%A8%E7%82%B9SafePoint/"/>
    <url>/2024/07/17/%E5%AE%89%E5%85%A8%E7%82%B9SafePoint/</url>
    
    <content type="html"><![CDATA[<h1 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h1><p>HotSpot 虚拟机并非在代码指令流的任意位置都能停下来开始垃圾回收的，而是强制要求必须执行到<strong>安全点</strong>后才能够暂停</p><p>安全点的选定基本上是以“是否具有让程序长时间执行的特征” 为标准进行选定的，最明显的特征是指令系列的复用，所以只有具有这些功能的指令才会产生安全点</p><ul><li>方法调用</li><li>循环跳转</li><li>异常跳转</li></ul><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>HotSpot 虚拟机为了避免安全点过多带来过重的负担，对循环有一项优化措施，认为循环次数较少的话，执行时间应该也不会太长</p><ul><li>使用 int 或者更小范围的数据类型作为索引的循环默认是不会放置安全点的，这种循环被称为可数循环；</li><li>使用 long 或者范围更大的数据类型作为索引值的循环就被称为不可数循环（Uncounted Loop）将会被放置安全点</li></ul><h2 id="native方法（JNI）"><a href="#native方法（JNI）" class="headerlink" title="native方法（JNI）"></a>native方法（JNI）</h2><p>当某个线程在执行 native 函数的时候，此时该线程在执行 JVM 管理以外的代码，不能对 JVM 的执行状态做任何修改，因而 JVM 要进入 SafePoint，所以也可以把正在执行 native 函数的线程看做 “已经进入了 SafePoint” 或者把这种情况叫做 “在 safe-region 里”</p><p>Thread.sleep(0) 方法就是一个 native 方法，是一个 JNI 调用，在返回 Java 这边的时候会进入 SafePoint</p><p>RocketMQ 的源码中 <code>Thread.sleep(0)</code> 的操作就是让他进入安全点</p><p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240716223334.png" alt="image.png"></p><h2 id="GC的时机"><a href="#GC的时机" class="headerlink" title="GC的时机"></a>GC的时机</h2><p>HotSpot会在所有方法的临返回之前，以及所有非counted loop的循环的回跳之前放置安全点</p><p>JVM 在做 GC 之前要等所有的应用线程进入到安全点之后 VM 线程才能分派 GC 任务，如果有线程一直没有进入到安全点，就会导致 GC 时JVM 停顿时间延长</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>（<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>；i&lt;<span class="hljs-number">1000000000</span>；i++)<br></code></pre></td></tr></table></figure><p>是一个典型的 Counted Loops 就是有明确的循环计数器变量，而且该变量有明确的起始值、终止值、步进长度的循环所以当这个循环运行时，JVM将无法停止线程</p><h2 id="GC要等所有线程进入安全点的例子"><a href="#GC要等所有线程进入安全点的例子" class="headerlink" title="GC要等所有线程进入安全点的例子"></a>GC要等所有线程进入安全点的例子</h2><ol><li>启动了两个长的、不间断的循环（内部没有安全点检查）。</li><li>主线程进入睡眠状态 1 秒钟。</li><li>在1000 ms之后，JVM尝试在Safepoint停止，以便Java线程进行定期清理，但是直到可数循环完成后才能执行此操作。</li><li>主线程的 Thread.sleep 方法从 native 返回，发现安全点操作正在进行中，于是把自己挂起，直到操作结束。<br>由于VMThread的某些操作需要STW，主线程在sleep结束前进入了JVM全局安全点，然后主线程要等待其他线程全部进入安全点，所以主线程被长时间没有进入安全点的其他线程给阻塞了</li></ol><p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240716223347.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 实现延迟队列</title>
    <link href="/2024/07/10/Redis%20%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/"/>
    <url>/2024/07/10/Redis%20%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>Redis 做延迟队列有两种方案：</p><ul><li>Redis 过期时间监听</li><li>Redisson 内置的延迟队列</li></ul><h2 id="Redis-过期事件监听实现延迟队列"><a href="#Redis-过期事件监听实现延迟队列" class="headerlink" title="Redis 过期事件监听实现延迟队列"></a>Redis 过期事件监听实现延迟队列</h2><p>Redis 有发布订阅（pub&#x2F;sub）功能，在 pub&#x2F;sub，引入了 <code>channel（频道）</code>，类似于消息队列的 topic （主题）</p><p>pub&#x2F;sub 涉及发布者<code>publisher</code> 和 订阅者 <code>subscriber</code> 两个角色</p><ul><li>发布者通过 <code>publish</code> 投递给指定的 channel</li><li>订阅者通过 subscribe 订阅一个或多个的 channel</li></ul><p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240811213610.png"></p><p>生产者指定消息到 channel，消费者订阅对应的 channel</p><p>Redis 中有很多默认的 channel，这些 channel 是由 Redis 本身向它们发送消息，<code>__keyevent@0__:expired</code> 就是一个默认的 channel，负责监听 key 的过期事件</p><p>当一个 key 过期之后，Redis 会发布一个 key 过期的事件到这个 channel 中</p><p>只需要监听这个 channel，就可以拿到过期的 key 的消息，进而实现了延迟队列</p><h3 id="缺点-1：时效性差"><a href="#缺点-1：时效性差" class="headerlink" title="缺点 1：时效性差"></a>缺点 1：时效性差</h3><p>过期事件是在 Redis 删除 key 时发布的，不是设置的过期时间到的时候直接发布</p><p>过期删除策略有 2 个</p><ul><li>惰性删除，对 CPU 友好，但是可能导致过期的 key 没有删除</li><li>定期删除，每隔一段时间抽取一批 key 执行删除，对内存友好</li></ul><p>Redis 采用的是 定期删除+惰性删除，因此会存在 key 过期了，但是事件还未发布</p><h3 id="缺点2：丢消息"><a href="#缺点2：丢消息" class="headerlink" title="缺点2：丢消息"></a>缺点2：丢消息</h3><p>Redis 中消息不支持持久化，当 channel 没有订阅者时，消息会被直接丢弃</p><h3 id="缺点3：多服务实例下存在消息重复问题"><a href="#缺点3：多服务实例下存在消息重复问题" class="headerlink" title="缺点3：多服务实例下存在消息重复问题"></a>缺点3：多服务实例下存在消息重复问题</h3><p>Redis 的消息队列只有广播模式，所有订阅指定 channel 的实例全都能收到消息，需要处理重复消费问题</p><h2 id="Redisson-内置的延迟队列实现"><a href="#Redisson-内置的延迟队列实现" class="headerlink" title="Redisson 内置的延迟队列实现"></a>Redisson 内置的延迟队列实现</h2><p>Redisson的延迟队列 RDelayedQueue 是基于 ZSet 实现的，需要执行延迟的任务插入到 ZSet 中，并给他们设置相应的过期时间作为分数</p><p>使用 <code>zrangebyscore</code> 命令扫描 ZSet 中过期的元素，然后将这些过期元素从 ZSet 中移除，并将它们加入到就绪消息列表中。就绪消息列表是一个阻塞队列，有消息进入就会被监听到。这样做可以避免对整个 ZSet 进行轮询，提高了执行效率</p><p>优势：</p><ul><li>减少了丢消息的可能：DelayedQueue 中的消息会被持久化，即使Redis宕机了，根据持久化机制，也只可能丢失一点消息，影响不大。也可以使用扫描数据库的方法作为补偿机制。</li><li>消息不存在重复消费问题：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Feed 流 —— Timeline</title>
    <link href="/2024/07/06/Timeline/"/>
    <url>/2024/07/06/Timeline/</url>
    
    <content type="html"><![CDATA[<h1 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h1><p>本文介绍基于关注关系并按时间排列的 Feed 流</p><p>Feed 流有两种工作模式，推模式和拉模式</p><h2 id="拉模式"><a href="#拉模式" class="headerlink" title="拉模式"></a>拉模式</h2><p>在用户查询时应该首先查询用户关注的所有博主的 <code>uid</code> 查询他们发布的作品，最后按照发布时间降序排列</p><p>拉模式用户每打开一次 “关注页” 系统就需要读取 N 个人的文章（N 为用户关注的博主数）所以拉模式又被称为<strong>读扩散</strong></p><p>拉模式不需要额外存储数据</p><ul><li>发布文章在 <code>articles</code> 表增加一条数据</li><li>用户关注在 <code>followings</code> 表中增加一条数据</li></ul><p>在粉丝数特别多的博主发布内容时，不需要进行特殊处理，等到用户进入关注页再计算就好</p><p>但是每次进入关注页都要进行大量读取和排序操作，如果用户关注的人比较多，一次拉取耗时会很大</p><h2 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h2><p>博主在发布文章的时候就要把新文章写入粉丝的 <code>Timeline</code> 中，用户每次只需要到自己关注的 <code>Timeline</code> 中</p><p>推模式每次发布文章都要写入 M 条数据（M 是粉丝数）所以推模式也叫<strong>写扩散</strong></p><p>在粉丝数比较多的博主，每次发布作品都要推送很多，体验不够友好</p><p>一般发布文章之后，前端返回成功，用 MQ 异步向粉丝 <code>Timeline</code> 推送</p><h2 id="在线推，离线拉"><a href="#在线推，离线拉" class="headerlink" title="在线推，离线拉"></a>在线推，离线拉</h2><p><code>Timeline</code> 实际上就是一个缓存</p><p>给 <code>Timeline</code> 的存储设置过期时间，如果用户一段时间没有打开 APP，<code>Timeline</code> 会失效，在他回归之后通过拉模式重建缓存即可</p><p>判断用户是否在线，也就可以通过 <code>Timeline</code> 缓存是否存在作为判断依据</p><p>并且用户总是关心关注页中最新的内容，所以 <code>Timeline</code> 也没必要存完整的数据，存最近一段时间的即可，旧数据等用户翻阅时重建</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>用 ZSet 存储，<code>article_id</code> 作为集合的 member，发布时间戳作为 score</p><p>推送的时候对目标 <code>Timeline</code> 的 ZSet 进行 ZAdd 操作，若缓存没有某个 <code>Timeline</code> 就用拉模式重建</p><p>存在的问题</p><ul><li><p>如果没有某个 <code>Timeline</code> 的缓存时，无法判断缓存是否失效了，还是这个用户的<code>Timeline</code> 本来就是空的，只能通过读取 MySQL 数据才能判断，会造成缓存穿透</p></li><li><p>由于只存储一段时间的 <code>Timeline</code> 所以当读完了 Redis 中的数据之后，无法判断数据库中是否有更久的数据</p></li></ul><p>解决办法：</p><ul><li>在 ZSet 中放一个 <code>noMore</code> 标志，表示数据库中没有更多的数据了，对于 <code>Timeline</code> 本来就为空的用户，他们 ZSet 中只有一个 <code>noMor</code> 标志</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点赞业务设计</title>
    <link href="/2024/07/03/%E7%82%B9%E8%B5%9E%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/07/03/%E7%82%B9%E8%B5%9E%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h1><p>内容点赞是一个非常高频的业务场景，功能本身复杂度不高，但是业务场景多，QPS 高，而且由于社区的用户体量，整体点赞的数据量非常大</p><p>点赞服务需要提供的接口有</p><ul><li>对某个内容点赞（取消点赞）、点踩（取消点踩）</li><li>查询是否对 单个 或者 一批内容 点过赞（踩） - 即点赞状态查询</li><li>查询某个内容的点赞数</li><li>查询某个用户的点赞列表</li><li>查询某个内容的点赞人列表</li><li>查询用户收到的总点赞数</li></ul><p>其中最核心的主要是</p><ul><li>用户是否点赞内容</li><li>内容点赞数</li></ul><p>在刷 Feed 流时，每一次下滑，都需要对数十篇内容进行登录用户是否点赞的判断</p><h2 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h2><p>用 Redis 的 set 结构进行存储用户 id</p><p><code>contentId: [userId1, userId2, ...]</code></p><p>用 set 的 <code>Sismember</code> 判断用户是否点赞，用 <code>Scard</code> 判断点赞数量</p><p>问题：</p><ul><li>如果是热点数据，点赞用户很多，容易出现<strong>大 Key</strong> 问题</li><li>缓存重建的时候需要查询全部点赞用户，容易出现<strong>慢查询</strong>问题</li></ul><h3 id="大-key-的危害"><a href="#大-key-的危害" class="headerlink" title="大 key 的危害"></a>大 key 的危害</h3><ul><li>对大 key 执行读请求，会使Redis 实例的带宽使用率被占满，导致自身服务变慢</li><li>对大 key 进行删除操作，易造成主库长时间阻塞</li></ul><h2 id="方案-2"><a href="#方案-2" class="headerlink" title="方案 2"></a>方案 2</h2><p>对大 Key 进行分片处理，对同一动态下的点赞用户，进行分片再放到缓存里，每次操作缓存时先根据 <code>userId</code> 计算分片值</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">contentId-<span class="hljs-number">1</span>: [<span class="hljs-keyword">user</span>Id1, <span class="hljs-keyword">user</span>Id11...]  // 把用户结尾为 <span class="hljs-number">1</span> 的全放到这里<br>contentId-<span class="hljs-number">2</span>: [<span class="hljs-keyword">user</span>Id2, <span class="hljs-keyword">user</span>Id22...]<br>contentId-<span class="hljs-number">3</span>: [<span class="hljs-keyword">user</span>Id3, <span class="hljs-keyword">user</span>Id33...]<br></code></pre></td></tr></table></figure><p>问题</p><ul><li>缓存分片仍然维护了被浏览动态下全部点赞数据，Feed 流场景下，用户浏览过的动态，几乎不会再次被浏览</li><li>一些点赞量多的历史动态，有人访问时会重建缓存，重建成本高，但是用率不高</li><li>分片增加了业务复杂性，增加了维护缓存的难度</li><li>分片会导致产生大量的 Key，Key 也会占用内存空间</li></ul><h2 id="方案-3"><a href="#方案-3" class="headerlink" title="方案 3"></a>方案 3</h2><p>使用 <code>Hash</code> 结构，<code>userId</code> 作为 key</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;userId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;ttl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1653532653</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;contentId1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//用户近一段时间点赞过的动态id</span><br><span class="hljs-attr">&quot;contentId2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//用户近一段时间点赞过的动态id</span><br><span class="hljs-attr">&quot;contentIdn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//用户近一段时间点赞过的动态id</span><br><span class="hljs-attr">&quot;minContentId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3540575</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//缓存中最小的动态id，用以区分冷热，</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>之前的方案访问老旧内容会重建缓存，性价比低，而且内容下点赞用户并不是一直活跃或重新访问的，所以先方案要区分冷热数据</li><li><code>contentId</code> 内容 id，是递增的，一定程度上反应了数据的冷热</li><li>缓存中只维护一定时间和一定数量的 <code>contentId</code> ，并增加 <code>minContentId</code> 字段用于区分冷热数据</li><li>对于冷数据，直接访问 DB，不再重建缓存</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式</title>
    <link href="/2024/06/29/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/06/29/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>观察者模式是一种一对多的关系，当一个对象状态发生改变时，所有依赖于它的对象都得到通知并完成更新</p><ul><li>被观察者（Observerable）：目标对象，状态发生变化时，通知所有的观察者</li><li>观察者（Observer）：接收被观察者状态变化通知</li></ul><p>例如异步通知场景</p><ol><li>定义被观察者</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observable</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Observer&gt; observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> state;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span>&#123;<br>        notifyAllObservers(state);<br>    &#125;<br><br>    <span class="hljs-comment">// 添加观察者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserve</span><span class="hljs-params">(Observer observer)</span>&#123;<br>        observers.add(observer);<br>    &#125;<br>    <span class="hljs-comment">// 移除观察者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserve</span><span class="hljs-params">(Observer observer)</span>&#123;<br>        observers.remove(observer);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAllObservers</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span>&#123;<br>        <span class="hljs-keyword">if</span> (state != <span class="hljs-number">1</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;不是通知状态&quot;</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Observer observer : observers) &#123;<br>            observer.doEvent();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>观察者接口以及实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 观察者方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doEvent</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doEvent</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;发邮件&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MobileObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doEvent</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>枚举实现责任链</title>
    <link href="/2024/06/26/%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E8%B4%A3%E4%BB%BB%E9%93%BE/"/>
    <url>/2024/06/26/%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E8%B4%A3%E4%BB%BB%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>责任链允许请求沿着处理者链进行处理，类似于拦截器</p><p>责任链由三部分组成</p><ul><li>抽象处理者（Handler）：定义一个处理请求的抽象类，包含处理方法和一个 next 指针</li><li>具体处理者：实现抽象处理者方法</li><li>客户端</li></ul><p>抽象处理者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayHandler</span> &#123;<br>    <span class="hljs-keyword">protected</span> GatewayHandler next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNext</span><span class="hljs-params">(GatewayHandler next)</span>&#123;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">handler</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiLimitGatewayHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GatewayHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(ApiLimitGatewayHandler.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">handler</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;Api 限流网关处理器执行中...&quot;</span>);<br>        <span class="hljs-comment">// ... 这里判断是否满足这个责任链</span><br>        <span class="hljs-comment">// 如果满足，看是否有下一个责任链，</span><br>        <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> next.handler();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlackListGatewayHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GatewayHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(BlackListGatewayHandler.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">handler</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;黑名单处理器执行中...&quot;</span>);<br>        <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> next.handler();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SessionGatewayHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GatewayHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(SessionGatewayHandler.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">handler</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;Session 处理器执行中...&quot;</span>);<br>        <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> next.handler();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来用枚举进行责任链的配置</p><p>目录结构：</p><p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240630130532.png"></p><ol><li>定义一个实体类，存放责任链的实体信息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayEntity</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String conference;  <span class="hljs-comment">// 全限定类名</span><br>    <span class="hljs-keyword">private</span> Integer handlerId; <br>    <span class="hljs-keyword">private</span> Integer preHandlerId;<br>    <span class="hljs-keyword">private</span> Integer nextHandlerId;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>定义一个枚举，里面存储 <code>GatewayEntity</code> （枚举本质上也是一个类，里面的枚举对象是用一个数组存储的）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">GatewayEnum</span> &#123;<br>    API_HANDLER(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GatewayEntity</span>(<span class="hljs-string">&quot;API 限流&quot;</span>, <span class="hljs-string">&quot;com.dong.demo.design.chain.impl.ApiLimitGatewayHandler&quot;</span>,<br>            <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>)),<br>    BLACKLIST_HANDLER(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GatewayEntity</span>(<span class="hljs-string">&quot;黑名単限流&quot;</span>, <span class="hljs-string">&quot;com.dong.demo.design.chain.impl.BlackListGatewayHandler&quot;</span>,<br>            <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)),<br>    SESSION_HANDLER(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GatewayEntity</span>(<span class="hljs-string">&quot;用户会话限流&quot;</span>, <span class="hljs-string">&quot;com.dong.demo.design.chain.impl.SessionGatewayHandler&quot;</span>,<br>            <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>));<br><br>    <span class="hljs-keyword">private</span> GatewayEntity gatewayEntity;<br><br>    GatewayEnum(GatewayEntity gatewayEntity)&#123;<br>        <span class="hljs-built_in">this</span>.gatewayEntity = gatewayEntity;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> GatewayEntity <span class="hljs-title function_">getGatewayEntity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> gatewayEntity;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>一个接口，获取第一个 <code>GatewayEntity</code> 和指定的 <code>GatewayEntity</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GatewayEntityService</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据 handlerId 获取配置项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handlerId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    GatewayEntity <span class="hljs-title function_">getGatewayEntity</span><span class="hljs-params">(Integer handlerId)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取第一个 handler</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    GatewayEntity <span class="hljs-title function_">getFirstGatewayEntity</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayEntityServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GatewayService</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GatewayEntity&gt; gatewayEntityMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        GatewayEnum[] values = GatewayEnum.values();<br>        <span class="hljs-keyword">for</span> (GatewayEnum value : values) &#123;<br>            <span class="hljs-type">GatewayEntity</span> <span class="hljs-variable">gatewayEntity</span> <span class="hljs-operator">=</span> value.getGatewayEntity();<br>            gatewayEntityMap.put(gatewayEntity.getHandlerId(), gatewayEntity);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> GatewayEntity <span class="hljs-title function_">getGatewayEntity</span><span class="hljs-params">(Integer handlerId)</span> &#123;<br>        <span class="hljs-keyword">return</span> gatewayEntityMap.get(handlerId);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> GatewayEntity <span class="hljs-title function_">getFirstGatewayEntity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, GatewayEntity&gt; entity : gatewayEntityMap.entrySet()) &#123;<br>            <span class="hljs-type">GatewayEntity</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entity.getValue();<br>            <span class="hljs-keyword">if</span> (value.getPreHandlerId() == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>一个工厂类，获取第一个 <code>handler</code> 并把其他的 <code>handler</code> 串联起来</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayHandlerEnumFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">GatewayEntityService</span> <span class="hljs-variable">gatewayService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GatewayEntityServiceImpl</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取第一个 handler</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GatewayHandler <span class="hljs-title function_">getFirstGatewayHandler</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">GatewayEntity</span> <span class="hljs-variable">firstGatewayEntity</span> <span class="hljs-operator">=</span> gatewayService.getFirstGatewayEntity();<br>        <span class="hljs-type">GatewayHandler</span> <span class="hljs-variable">firstGatewayHandler</span> <span class="hljs-operator">=</span> newGatewayHandler(firstGatewayEntity);<br>        <span class="hljs-keyword">if</span> (firstGatewayHandler == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">GatewayEntity</span> <span class="hljs-variable">curGatewayEntity</span> <span class="hljs-operator">=</span> firstGatewayEntity;<br>        <span class="hljs-type">GatewayHandler</span> <span class="hljs-variable">curGatewayHandler</span> <span class="hljs-operator">=</span> firstGatewayHandler;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">nextHandlerId</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> ((nextHandlerId = curGatewayEntity.getNextHandlerId()) != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">GatewayEntity</span> <span class="hljs-variable">gatewayEntity</span> <span class="hljs-operator">=</span> gatewayService.getGatewayEntity(nextHandlerId);<br>            <span class="hljs-type">GatewayHandler</span> <span class="hljs-variable">gatewayHandler</span> <span class="hljs-operator">=</span> newGatewayHandler(gatewayEntity);<br>            curGatewayHandler.setNext(gatewayHandler);<br>            curGatewayEntity = gatewayEntity;<br>            curGatewayHandler = gatewayHandler;<br>        &#125;<br>        <span class="hljs-keyword">return</span> firstGatewayHandler;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反射实例化具体的处理者</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> gatewayEntity</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> GatewayHandler <span class="hljs-title function_">newGatewayHandler</span><span class="hljs-params">(GatewayEntity gatewayEntity)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> gatewayEntity.getConference();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; clazz = Class.forName(className);<br>            <span class="hljs-keyword">return</span> (GatewayHandler) clazz.newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>一个客户端进行测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GatewayHandler</span> <span class="hljs-variable">firstGatewayHandler</span> <span class="hljs-operator">=</span> GatewayHandlerEnumFactory.getFirstGatewayHandler();<br>        firstGatewayHandler.handler();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模版方法模式</title>
    <link href="/2024/06/25/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/06/25/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>定义操作中的骨架流程，将一些步骤延迟加载到子类中，使子类可以不改变结构即可重新定义该流程的特定步骤</p><ol><li>一个抽象类，定义骨架流程</li></ol><p>例如一个请求经过流程分为如下步骤</p><ul><li>解析请求头</li><li>封装数据</li><li>返回请求体</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractRequestService</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolveHead</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolve</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolveBody</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模版方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolveRequest</span><span class="hljs-params">()</span>&#123;<br>        resolveHead();<br>        resolve();<br>        resolveBody();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>实现类实现父类中的 <code>abstract</code> 方法，父类引用指向子类对象</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/2024/06/24/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/06/24/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>有多个 <code>if...else</code> 等条件分支，并且每个条件分支，可以封装起来替换的，可以使用策略模式来优化</p><ol><li>一个接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IFileStrategy</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 输入哪种文件类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    FileTypeEnum <span class="hljs-title function_">getFileType</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 具体解析方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> param</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolve</span><span class="hljs-params">(Object param)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>一个枚举，及实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">FileTypeEnum</span> &#123;<br>    A,<br>    B,<br>    C;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AFileResolve</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFileStrategy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(AFileResolve.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileTypeEnum <span class="hljs-title function_">getFileType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> FileTypeEnum.A;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolve</span><span class="hljs-params">(Object param)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;A 类型解析文件，参数：&#123;&#125;&quot;</span>, param);<br>        <span class="hljs-comment">// A 类型解析</span><br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BFileResolve</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFileStrategy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(BFileResolve.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileTypeEnum <span class="hljs-title function_">getFileType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> FileTypeEnum.B;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolve</span><span class="hljs-params">(Object param)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;B 类型解析文件，参数：&#123;&#125;&quot;</span>, param);<br>        <span class="hljs-comment">// B 类型解析</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>用 <code>ApplicationContextAware</code> 接口，把策略初始化到 map 里面</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyUseService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;FileTypeEnum, IFileStrategy&gt; iFileStrategyMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolveFile</span><span class="hljs-params">(FileTypeEnum fileTypeEnum, Object param)</span>&#123;<br>        <span class="hljs-type">IFileStrategy</span> <span class="hljs-variable">iFileStrategy</span> <span class="hljs-operator">=</span> iFileStrategyMap.get(fileTypeEnum);<br>        <span class="hljs-keyword">if</span> (iFileStrategy != <span class="hljs-literal">null</span>) &#123;<br>            iFileStrategy.resolve(param);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        Map&lt;String, IFileStrategy&gt; tempMap = applicationContext.getBeansOfType(IFileStrategy.class);<br>        tempMap.values().forEach(strategyService -&gt; iFileStrategyMap.put(strategyService.getFileType(), strategyService));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列幂等方案</title>
    <link href="/2024/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B9%82%E7%AD%89%E6%96%B9%E6%A1%88/"/>
    <url>/2024/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B9%82%E7%AD%89%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>如果一个消息队列对某个消息发送了两次，导致入库两条相同的数据，如何避免</p></blockquote><p>也即如何保证幂等性，接下来讨论的前提是全局唯一 ID</p><h1 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h1><p>最简单的方案，先查 ID 在数据库里有没有，如果没有则入库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">vo = select(id);<br><span class="hljs-keyword">if</span> (vo == <span class="hljs-literal">null</span>)&#123;<br>  save(信息)<br>&#125;<br></code></pre></td></tr></table></figure><p>先查询，再判断，再保存，在多线程的情况下，还是拦不住</p><p>可以在数据表中加<strong>唯一索引</strong>方案解决，在数据库层面抛异常，来保证幂等</p><p>如果要保证少抛异常，看接下来的方案</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>为了保证在并发条件下，也只有一个请求到数据库，可以用锁的方式</p><p>以 id 为 key 加锁，如果加锁成功，则放行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">flag = addRedisLock(id, 过期时间);<br><span class="hljs-keyword">if</span> (flag)&#123;<br>  save(信息)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果此时 Redis 锁成功了，但是还没 save，Redis 重启了，理论上是可以重试的，但是由于 Redis 锁的存在，导致不会走到 save 的逻辑</p><ul><li><p>人工介入，删除 Redis 对应的 key</p></li><li><p>由于设置了过期时间，等过期时间过了之后的请求理论上还是可以拿到锁，所以加一个重试机制</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">flag = addRedisLock(id, 过期时间, 获取不到则等待);<br><span class="hljs-keyword">if</span> (flag)&#123;<br>  save(信息)<br>&#125;<br></code></pre></td></tr></table></figure><p>由于有锁等待的逻辑，如果两个请求过来，还是有可能都放到 Redis 里，save 方法还是会走两遍，所以还需要加一个查询数据库的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">flag = addRedisLock(id, 过期时间, 获取不到则等待);<br><span class="hljs-keyword">if</span> (flag)&#123;<br>  vo = select(id);<br>  <span class="hljs-keyword">if</span> (vo == <span class="hljs-literal">null</span>)&#123;<br>    save(信息);<br>  &#125;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 等待结束后还是未获取到锁，发送预警</span><br>  monitor(预警信息);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>最开始加唯一索引需求是根据业务表来做的，如果出现问题就让它抛出主键异常</p><p>如何设计一个通用技术组件，不依赖于业务场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">vo = select <span class="hljs-keyword">for</span> <span class="hljs-title function_">update</span><span class="hljs-params">(id)</span>;<br><span class="hljs-keyword">if</span> (vo == <span class="hljs-literal">null</span>)&#123;<br>  save(message);<br>&#125;<br></code></pre></td></tr></table></figure><p>也是加锁，但是这样性能就太差了</p><p>设计一个 <code>消息消费记录表</code> 专门为了解决幂等问题而存在的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (保存数据到消息消费记录表)&#123; <span class="hljs-comment">// 出现主键冲突就返回 false</span><br>  save(message);<br>&#125;<br></code></pre></td></tr></table></figure><p>先判断，再保存，非原子性，多线程情况下也不行</p><p>加入事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">begin transaction;<br><span class="hljs-keyword">if</span> (保存数据到消息消费记录表)&#123; <span class="hljs-comment">// 出现主键冲突就返回 false</span><br>  save(message);<br>&#125;<br>end transaction;<br></code></pre></td></tr></table></figure><p>一般来说，能不用事务就不使用事务，通过最终一致性来保证数据完整性</p><p>所以可以在 <code>消费记录表</code> 中加一个状态字段，状态有两个取值：消费中，消费完成</p><p>同时把唯一索引改成 <code>消息唯一标识 + 状态</code></p><p>首先 MQ 发起请求，数据往消费记录表中插入，状态是“消费中”<br>如果插入成功，说明第一次消费，进入到业务逻辑中</p><ul><li>如果业务逻辑执行成功，则更新消费记录表对应数据为“消费完成”</li><li>如果业务执行失败，删除消费记录表对应的数据，把消息扔回 MQ，等待下次重试<br>如果插入失败，说明重复消费，直接丢弃</li></ul><p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240630134342.png"></p><p>其实插入失败这里还应该判断状态是否是消费成功的，如果是消费成功的，才应该丢弃</p><p><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240630134704.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redission tryLock</title>
    <link href="/2024/05/28/Redission-tryLock/"/>
    <url>/2024/05/28/Redission-tryLock/</url>
    
    <content type="html"><![CDATA[<h1 id="Redisson-的-tryLock"><a href="#Redisson-的-tryLock" class="headerlink" title="Redisson 的 tryLock"></a>Redisson 的 tryLock</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit)</span><br></code></pre></td></tr></table></figure><p>在 waitTime 时间范围内尝试获取锁, 如果获取到锁, 设置过期时间 leaseTime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonLock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RedissonBaseLock</span> &#123;<br>    <span class="hljs-comment">// 在waitTime时间范围内尝试获取锁，如果获取到锁，则设置锁过期时间leaseTime</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> unit.toMillis(waitTime);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-comment">// 第一步：尝试获取锁</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">ttl</span> <span class="hljs-operator">=</span> tryAcquire(waitTime, leaseTime, unit, threadId);<br>        <span class="hljs-comment">// ttl为空说明获取到了锁</span><br>        <span class="hljs-keyword">if</span> (ttl == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 判断尝试获取锁是否超过waitTime</span><br>        time -= System.currentTimeMillis() - current;<br>        <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>) &#123;<br>            acquireFailed(waitTime, unit, threadId);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 第二步：订阅解锁消息通知</span><br>        current = System.currentTimeMillis();<br>        <span class="hljs-comment">// 订阅锁释放</span><br>        RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);<br>        <span class="hljs-comment">// 等待锁释放消息，等待时间超过waitTime，获取锁失败</span><br>        <span class="hljs-keyword">if</span> (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) &#123;<br>            <span class="hljs-comment">// 如果订阅解锁Future在执行中，等任务执行完后取消订阅锁释放</span><br>            <span class="hljs-keyword">if</span> (!subscribeFuture.cancel(<span class="hljs-literal">false</span>)) &#123;<br>                subscribeFuture.onComplete((res, e) -&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">// 取消订阅解锁通知</span><br>                        unsubscribe(subscribeFuture, threadId);<br>                    &#125;<br>                &#125;);<br>            &#125;<br>            acquireFailed(waitTime, unit, threadId);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 判断尝试获取锁是否超过waitTime</span><br>            time -= System.currentTimeMillis() - current;<br>            <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>) &#123;<br>                acquireFailed(waitTime, unit, threadId);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        <br>            <span class="hljs-comment">// 第三步：自旋尝试获取锁</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>                <span class="hljs-comment">// 1、尝试获取锁(下文会详细解析此方法)</span><br>                ttl = tryAcquire(waitTime, leaseTime, unit, threadId);<br>                <span class="hljs-comment">// ttl为空说明获取到了锁</span><br>                <span class="hljs-keyword">if</span> (ttl == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 判断尝试获取锁是否超过waitTime</span><br>                time -= System.currentTimeMillis() - currentTime;<br>                <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>) &#123;<br>                    acquireFailed(waitTime, unit, threadId);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 等待锁释放（信号量控制）</span><br>                currentTime = System.currentTimeMillis();<br>                <span class="hljs-keyword">if</span> (ttl &gt;= <span class="hljs-number">0</span> &amp;&amp; ttl &lt; time) &#123;<br>                    <span class="hljs-comment">// 尝试获取信号量</span><br>                    subscribeFuture.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    subscribeFuture.getNow().getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);<br>                &#125;<br><br>                <span class="hljs-comment">// 判断尝试获取锁是否超过waitTime</span><br>                time -= System.currentTimeMillis() - currentTime;<br>                <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>) &#123;<br>                    acquireFailed(waitTime, unit, threadId);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 第四步：取消解锁订阅</span><br>            unsubscribe(subscribeFuture, threadId);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要分为以下四步</p><ul><li>tryAcquire 尝试获取锁, 获取到返回 true</li><li>获取不到说明锁被占用了, 订阅结果消息通知</li><li>收到消息解锁通知, 自旋获取锁, 直到 waitTime 获取锁失败</li><li>不论是否获取锁成功, 取消解锁消息订阅</li></ul><p>tryAcquire 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Long <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId)</span> &#123;<br>    <span class="hljs-keyword">return</span> get(tryAcquireAsync(waitTime, leaseTime, unit, threadId));<br>&#125;<br><br><span class="hljs-keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="hljs-title function_">tryAcquireAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId)</span> &#123;<br>    RFuture&lt;Long&gt; ttlRemainingFuture;<br>    <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1</span>) &#123;<br>        ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 这里需要注意的是leaseTime == -1，会触发redisson看门狗机制</span><br>        ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,<br>                TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);<br>    &#125;<br>    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取锁成功</span><br>        <span class="hljs-keyword">if</span> (ttlRemaining == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1</span>) &#123;<br>                internalLockLeaseTime = unit.toMillis(leaseTime);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 锁自动续时（看门狗机制）触发条件leaseTime == -1</span><br>                scheduleExpirationRenewal(threadId);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> ttlRemainingFuture;<br>&#125;<br></code></pre></td></tr></table></figure><p>tryLockInnerAsync 里面是尝试获取分布式锁的 lua 脚本<br>scheduleExpirationRenewal 锁自动续时, 看门狗机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T&gt; RFuture&lt;T&gt; <span class="hljs-title function_">tryLockInnerAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> &#123;<br>    <span class="hljs-keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,<br>            <span class="hljs-comment">// 如果key一开始就不存在，则直接创建一个key</span><br>            <span class="hljs-string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +<br>                    <span class="hljs-string">&quot;return nil; &quot;</span> +<br>                    <span class="hljs-string">&quot;end; &quot;</span> +<br>                    <span class="hljs-comment">// 这里是重入锁的实现，同一个线程多次获取锁只需要在value加1即可，value相当于一个加锁计数器</span><br>                    <span class="hljs-string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +<br>                    <span class="hljs-string">&quot;return nil; &quot;</span> +<br>                    <span class="hljs-string">&quot;end; &quot;</span> +<br>                    <span class="hljs-comment">// 有其他线程持有锁，加锁失败，返回锁过期时间</span><br>                    <span class="hljs-string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,<br>            Collections.singletonList(getRawName()), unit.toMillis(leaseTime), getLockName(threadId));<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>加锁的 key 不存在就创建一个 redis hash key, field(当前线程 id), value(加锁次数)</li><li>有线程持有锁并且未解锁, 其他线程无法获取到锁</li><li>加锁成功返回 null, 加锁失败返回过期时间</li></ol><p>锁过期时间自动续费</p><ol><li>锁过期自动续费的触发条件为 tryLock 设置的锁到期时间为-1</li><li>自动续费的原理是创建一个定时任务, 每 internalLockLeaseTime &#x2F; 3 时触发一次, 如果发现持有锁未释放, 把锁过期时间更新为 internalLockLeaseTime(默认为 30s)</li><li>锁过期时间更新后, 再次递归调用 renewExpiration 创建下一次定时任务</li></ol><p>前面 tryLock 方法的订阅解锁消息通知是在 unlock 的时候发起的<br>unlockAsync 方法内部调用 lua 脚本, 调用 publish 推送解锁消息</p><p>Redis 的 publish</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs redis">publish channel message<br></code></pre></td></tr></table></figure><ul><li>channel 指定要发布消息的频道</li><li>message 要发布的消息内容<br>在 tryLock 和 unLock 中, 他们的 channel 是线程 id</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2024/05/28/Spring/"/>
    <url>/2024/05/28/Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h2><ul><li>通过 BeanDefinition 获取 Bean 的定义信息</li><li>通过构造函数实例化 Bean</li><li>Bean 的依赖注入</li><li>处理 Aware 接口</li><li>BeanPostProcessor - 前置方法</li><li>初始化方法(InitializingBean, init-method)</li><li>BeanPostProcessor - 后置方法</li><li>销毁 Bean</li></ul><p>BeanDefinition 是 Spring 容器在进行实例化时, 会将 xml 配置的 <code>&lt;bean&gt;</code> 信息封装成一个 BeanDefinition 对象, Spring 根据它来创建 Bean 对象<br><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240305171200.png" alt="image.png"></p><h2 id="Aware-接口有什么用"><a href="#Aware-接口有什么用" class="headerlink" title="Aware 接口有什么用"></a>Aware 接口有什么用</h2><ul><li>通过实现特定的 Aware 接口, bean 可以获得对 Spring 容器的某些部分(如配置文件, 文件资源, 环境属性等) 的访问权</li><li>ApplicationContextAware: 允许一个 bean 获得对 ApplicationContext 的访问, 意味着该 bean 可以访问 Spring 容器的所有配置信息的定义</li><li>BeanNameAware: 它会在创建过程中接收到自己在容器中的名称</li><li>BeanFactoryAware: Bean 可以直接访问到它所在的 BeanFactory, 从而允许请求其他 Bean 等操作</li><li>实现这些接口可以让不是在 Spring 的环境下, 获取 Spring 的 Bean, 例如通过 BeanFactory</li></ul><h2 id="InitializingBean-有什么作用"><a href="#InitializingBean-有什么作用" class="headerlink" title="InitializingBean 有什么作用"></a>InitializingBean 有什么作用</h2><ul><li>用于在初始化方法完成后执行自定义初始化逻辑</li><li>当一个 Bean 实现了 InitializingBean 接口时, Spring 容器在初始化Bean 并完成所有属性设置后会调用 <code>afterPropertiesSet()</code> 方法来执行额外初始化操作</li></ul><h2 id="Spring-出现循环依赖"><a href="#Spring-出现循环依赖" class="headerlink" title="Spring 出现循环依赖"></a>Spring 出现循环依赖</h2><ul><li>循环依赖是指两个或多个 Bean 相互依赖, A 依赖于 B, B 依赖于 A</li></ul><h3 id="构造器注入循环依赖能解决吗"><a href="#构造器注入循环依赖能解决吗" class="headerlink" title="构造器注入循环依赖能解决吗"></a>构造器注入循环依赖能解决吗</h3><ul><li>如果 A 和 B 都用构造器注入不行, 因为在创建 Bean 实例时需要调用构造函数创建 Bean</li><li>但是一个使用 Setter 注入, 一个使用构造器注入需要分情况考虑<ul><li>A 用 Setter 注入 B, B 用构造器注入 A, 可以解决循环依赖</li><li>A 用构造器注入 B, B 用 Setter 注入 A, 不可以解决</li><li>因为 Spring 在创建 Bean 的时候默认是按照自然排序进行创建, A 会优先于 B 创建</li></ul></li></ul><h2 id="Spring-创建-Bean-简单的三步"><a href="#Spring-创建-Bean-简单的三步" class="headerlink" title="Spring 创建 Bean 简单的三步"></a>Spring 创建 Bean 简单的三步</h2><ul><li>实例化: 对应方法 <code>AbstractAutowireCapableBeanFactory</code> 的 <code>createBeanInstance</code> 方法</li><li>属性注入: 对应方法 <code>AbstractAutowireCapableBeanFactory</code> 的 <code>populateBean</code> 方法</li><li>初始化: 对应方法 <code>AbstractAutowireCapableBeanFactory</code> 的 <code>initializeBean</code><br>其实就是</li><li>实例化, new 了一个对象</li><li>属性注入: 为 new 的对象填充属性</li><li>初始化: 执行 aware 接口中的方法, 完成 AOP 代理</li></ul><h2 id="Spring-三级缓存"><a href="#Spring-三级缓存" class="headerlink" title="Spring 三级缓存"></a>Spring 三级缓存</h2><ul><li><code>singletonObjects</code> 一级缓存: 存储创建好的单例 Bean</li><li><code>earlySingletonObjects</code> 二级缓存: 完成实例化, 还未进行属性注入及初始化的对象</li><li><code>singletonFactories</code> 三级缓存: 提前暴露一个单例工厂, 二级缓存中存储的就是从这个工厂中获取的对象</li></ul><h2 id="SpringMVC-的执行流程"><a href="#SpringMVC-的执行流程" class="headerlink" title="SpringMVC 的执行流程"></a>SpringMVC 的执行流程</h2><ul><li>用户发送请求到前端控制器 DispatchServlet</li><li>DispatchServlet 收到请求, 调用 HandlerMapper</li><li>HandlerMapper 找到具体的处理器, 生成处理器对象及处理器拦截器(如果有) 一起返回 DispatchServlet</li><li>DispatchServlet 调用 HandlerAdapter(处理器适配器)</li><li>HandlerAdapter 调用具体的 Controller</li></ul><h2 id="SpringBoot-自动装配原理-or-启动流程"><a href="#SpringBoot-自动装配原理-or-启动流程" class="headerlink" title="SpringBoot 自动装配原理 or 启动流程"></a>SpringBoot 自动装配原理 or 启动流程</h2><ul><li>在 SpringBoot 启动类上有一个 <code>@SpringBootApplication</code> 注解, 其中封装了三个注解<ul><li><code>@SpringBootConfiguration</code></li><li><code>@EnableAutoConfiguration</code></li><li><code>@ComponentScan</code></li></ul></li><li>其中 <code>@EnableAutoConfiguration</code> 是实现自动配置的核心注解, 该注解通过 <code>@Import</code> 注解导入对应的配置选择器类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br></code></pre></td></tr></table></figure></li><li>配置选择器类内部读取该项目和该项目引用 jar 包的 classpath 路径下的 META-INF&#x2F;spring.factories 文件, 该文件里有所需要加载的类的全限定类名, 会根据 bean 的条件注解决定是否将其导入 Spring 容器中<ul><li>条件注解有像 <code>@ConditionalOnClass</code> 这样的注解, 表示有对应的 class 文件, 才加载</li></ul></li></ul><h2 id="SpringBoot-依赖管理"><a href="#SpringBoot-依赖管理" class="headerlink" title="SpringBoot 依赖管理"></a>SpringBoot 依赖管理</h2><ul><li>继承了 <code>spring-boot-starter-parent</code>  其又继承了 <code>spring-boot-dependencies</code> 内部定义了很多依赖</li></ul><h2 id="spring-boot-starter-跟-spring-boot-starter-web-有什么区别"><a href="#spring-boot-starter-跟-spring-boot-starter-web-有什么区别" class="headerlink" title="spring-boot-starter 跟 spring-boot-starter-web 有什么区别"></a>spring-boot-starter 跟 spring-boot-starter-web 有什么区别</h2><ul><li><code>spring-boot-starter</code> 是许多其他 Starter 的基础依赖, 但不包含任何特定的功能模块, 它包含以下内容<ul><li>Spring Core</li><li>Spring Context</li><li>Spring AOP</li></ul></li><li><code>spring-boot-starter-web</code> 是专门用于构建 Web 应用的 Starter 依赖, 能处理 HTTP 请求, 它里面包含 <code>spring-boot-starter</code> <ul><li>Spring Web</li><li>Spring MVC</li><li>Jackson</li><li>Tomcat</li></ul></li></ul><h2 id="Spring-常用的类"><a href="#Spring-常用的类" class="headerlink" title="Spring 常用的类"></a>Spring 常用的类</h2><ul><li><code>ApplicationContext</code> Spring 容器接口, 负责创建和管理 Spring Bean</li><li><code>BeanFactory</code> Spring 容器, 提供 Bean 的基础管理</li><li><code>BeanDefinition</code> </li><li><code>InitializingBean</code></li><li>一些 Aware 接口</li></ul><h2 id="Spring-自动注入原理"><a href="#Spring-自动注入原理" class="headerlink" title="Spring 自动注入原理"></a>Spring 自动注入原理</h2><ul><li>使用反射机制将依赖注入到 Bean 中<ul><li>构造器注入</li><li>Setter 方法注入</li><li>字段注入</li></ul></li></ul><h2 id="get-和-post-有什么区别"><a href="#get-和-post-有什么区别" class="headerlink" title="get 和 post 有什么区别"></a>get 和 post 有什么区别</h2><ul><li>get 参数拼接在 Url 后面, post 参数在请求体里, 相对安全</li><li>数据大小限制, get 受到 Url 长度的限制, post 理论上没有大小限制</li><li>幂等性, get 是幂等的, post 是非幂等的</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU</title>
    <link href="/2024/05/28/%E5%8A%9B%E6%89%A3-LRU/"/>
    <url>/2024/05/28/%E5%8A%9B%E6%89%A3-LRU/</url>
    
    <content type="html"><![CDATA[<h1 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h1><p>LRU，Least Recently Used，最少最近使用，淘汰策略是最久没用的<br>想象有一摞书，用的时候抽出来，放在最上面<br>淘汰的时候把最下面的移除<br>整一个双向链表，每次都淘汰最后一个，插入的时候插入到头（哨兵后面）<br><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240314221217.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>        <span class="hljs-type">int</span> key, value;<br>        Node pre, next;<br>        Node(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)&#123;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 哨兵节点</span><br>    <span class="hljs-comment">// 存储 key 和 Node 的关系，方便检索</span><br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Node&gt; key2Node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>(); <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        dummy.pre = dummy;<br>        dummy.next = dummy;<br>    &#125;<br>    <span class="hljs-comment">// 移除某一个节点（抽出一本书）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Node node)</span>&#123;<br>        node.pre.next = node.next;<br>        node.next.pre = node.pre;<br>    &#125;<br>    <span class="hljs-comment">// 把节点添加到链表头（把一本书放到最上面）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushFront</span><span class="hljs-params">(Node node)</span>&#123;<br>        node.pre = dummy;<br>        node.next = dummy.next;<br>        node.pre.next = node;<br>        node.next.pre = node;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span>&#123;<br>        <span class="hljs-keyword">if</span> (!key2Node.containsKey(key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> key2Node.get(key);  <span class="hljs-comment">// 如果有的话，最近使用过</span><br>        <span class="hljs-comment">// 要把它放到最上面，也就是先移除再插入</span><br>        remove(node);<br>        pushFront(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNode(key);<br>        <span class="hljs-keyword">return</span> node == <span class="hljs-literal">null</span> ? -<span class="hljs-number">1</span> : node.value;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNode(key);<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>)&#123;  <span class="hljs-comment">// 有这本书</span><br>            node.value = value;  <span class="hljs-comment">// 更新 value</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, value);  <span class="hljs-comment">// 新书</span><br>        key2Node.put(key, node);<br>        pushFront(node);  <span class="hljs-comment">// 放到最上面</span><br>        <span class="hljs-keyword">if</span> (key2Node.size() &gt; capacity)&#123;  <span class="hljs-comment">// 淘汰策略</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">backNode</span> <span class="hljs-operator">=</span> dummy.pre;<br>            key2Node.remove(backNode.key);<br>            remove(backNode);  <span class="hljs-comment">// 移除最后一个</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2024/05/27/MySQL/"/>
    <url>/2024/05/27/MySQL/</url>
    
    <content type="html"><![CDATA[<ul><li><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="redo-log-和-binlog-的区别"><a href="#redo-log-和-binlog-的区别" class="headerlink" title="redo log 和 binlog 的区别"></a>redo log 和 binlog 的区别</h2><ul><li>redo log 是 InnoDB 特有的, binlog 是 Server 层的每个数据引擎都有</li><li>redo log 记录的是物理日志, 记录的是在某个数据页做的修改, 比如”对 xxx 表中 yyy 数据页 zzz 偏移量的地方坐了 aaa 更新” binlog 是逻辑日志, 记录的是这个语句的原始逻辑, 比如”给 id &#x3D; 2 的字段 c 加 1”</li><li>redo log 是循环写的, 空间会用完, binlog 是追加写的</li></ul><h2 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a>聚簇索引和二级索引</h2><ul><li>InnoDB 使用了 B+ 树索引模型</li><li>主键索引的叶子节点存储的是整行数据, 在 InnoDB 中, 主键索引也被称为聚簇索引</li><li>非主键索引的叶子节点存储的是主键值, 在 InnoDB 中, 非主键索引也被称为二级索引</li></ul><h2 id="为什么用-B-树做索引"><a href="#为什么用-B-树做索引" class="headerlink" title="为什么用 B+ 树做索引"></a>为什么用 B+ 树做索引</h2><h3 id="什么样的数据结构是好的索引"><a href="#什么样的数据结构是好的索引" class="headerlink" title="什么样的数据结构是好的索引?"></a>什么样的数据结构是好的索引?</h3><ul><li>MySQL 是持久化到磁盘的, 因此当我们通过索引查找某行数据的时候, 需要先从磁盘读取索引到内存, 再通过索引从磁盘中找到某行数据, 然后读入内存, 也就是说查询的过程中会发生多次 IO 操作, IO 操作次数越多, 性能损耗越大</li><li>MySQL 是支持范围查找的, 所以索引数据不仅能高效查找某一个记录, 而且也要能高效执行范围查找</li><li>所以一个合适的索引要满足<ul><li>尽可能少的进行 IO 操作</li><li>能高效查找某一个记录, 也能高效进行范围查找</li></ul></li></ul><h3 id="各个数据结构对比"><a href="#各个数据结构对比" class="headerlink" title="各个数据结构对比"></a>各个数据结构对比</h3><ul><li>顺序结构, 可以用二分来查找, 速度快, 但是插入性能太低</li><li>二叉搜索树, 不支持范围查找, 而且有退化成链表的风险</li><li>平衡二叉树, 不支持范围查找, 并且由于是二叉树, 随着元素增多, 树的高度变高, 磁盘 IO 次数增加</li><li>B 树, B 树可以是多叉树, 但是每个节点都存储索引+数据, 而数据的大小可能远远超过索引大小</li><li>B+树, 叶子结点才会存放实际数据, 非叶子节点只会存放索引, 叶子节点构成一个有序链表</li></ul><h3 id="InnoDB-中的-B-树"><a href="#InnoDB-中的-B-树" class="headerlink" title="InnoDB 中的 B+ 树"></a>InnoDB 中的 B+ 树</h3><ul><li>叶子节点用双向链表进行连接, 既能向左遍历, 也能向右遍历</li><li>叶子节点内容是数据页, 数据页存放了数据以及各种信息, 每个数据页默认大小 16KB</li></ul><h2 id="什么是两阶段锁"><a href="#什么是两阶段锁" class="headerlink" title="什么是两阶段锁"></a>什么是两阶段锁</h2><ul><li>在 InnoDB 事务中, 行锁是在需要的时候加上的, 但并不是不需要了就立即释放, 而是等到事务结束才释放</li></ul><h2 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h2><ul><li>快照读中, 事务读取的是数据快照, 即事务开始时的数据状态</li><li>当前读中, 事务读取的是数据库当前数据状态, 即最新数据, 如果有锁的话阻塞等待</li><li>可重复读的隔离级别下<ul><li>select 默认快照读</li><li>select 加锁是当前读<ul><li>select a from t where id &#x3D; 1 lock in share mode 共享锁</li><li>select a from t where id for update 排他锁</li></ul></li><li>update 语句是当前读</li></ul></li></ul><h2 id="索引创建原则"><a href="#索引创建原则" class="headerlink" title="索引创建原则"></a>索引创建原则</h2><ul><li>数据量大, 且查询频繁的时候要创建索引</li><li>为常作为查询条件, 排序, 分组的字段创建索引</li><li>字段的内容区分度要高</li><li>内容较长的情况下, 使用前缀索引</li><li>尽量使用联合索引, 这样可以进行覆盖查询, 方式回表</li><li>要控制索引的数量</li></ul><h2 id="什么情况下索引会失效"><a href="#什么情况下索引会失效" class="headerlink" title="什么情况下索引会失效"></a>什么情况下索引会失效</h2><ul><li>联合索引中违反最左前缀法则</li><li>联合索引中范围查询的右边的列, 不能使用索引</li><li>索引列上进行运算操作, 索引失效</li><li>索引列进行类型转换, 比如字符串不加单引号, 索引失效</li><li>以%开头的 like 模糊查询, 索引失效</li></ul><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><ul><li>是一种快速搜索文本数据的索引, 适用于需要处理大量自然语言文本的应用场景</li><li>底层由倒排索引实现<ul><li>词典: 存储每一个词</li><li>倒排列表: 记录每个词在文档中出现的位置</li></ul></li></ul><h2 id="慢查询出现的原因"><a href="#慢查询出现的原因" class="headerlink" title="慢查询出现的原因"></a>慢查询出现的原因</h2><ul><li>没有使用索引或者索引不当</li><li>复杂的 join 操作, 尤其涉及大量数据的表</li><li>子查询过多</li><li>表结构设计不合理, 过多的冗余设计</li><li>数据量过大</li><li>服务器的硬件资源不粗</li></ul><h2 id="优化慢查询"><a href="#优化慢查询" class="headerlink" title="优化慢查询"></a>优化慢查询</h2><ul><li>先运行看看是否真的很慢，注意设置 SQL_NO_CACHE</li><li>WHERE 条件单表查，锁定最小返回记录表<ul><li>在涉及多个表的查询中，应该从返回记录最少的表开始查询，以减少数据处理的开销</li><li>对于单表查询，通过 WHERE 条件逐个应用到表中的每个字段，找出区分度最高的字段，这样可以更高效地过滤数据<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 假设有两个表</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> A, B <span class="hljs-keyword">WHERE</span> A.id <span class="hljs-operator">=</span> B.id <span class="hljs-keyword">AND</span> A.status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;active&#x27;</span> <span class="hljs-keyword">AND</span> B.type <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;premium&#x27;</span>;<br><span class="hljs-comment">-- 分析单标 where 条件效果</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> A <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;active&#x27;</span>; <span class="hljs-comment">-- 结果记录数较多</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> B <span class="hljs-keyword">WHERE</span> type <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;premium&#x27;</span>;  <span class="hljs-comment">-- 结果记录数较少</span><br><span class="hljs-comment">-- 优先从记录较少的 B 表开始查</span><br></code></pre></td></tr></table></figure></li></ul></li><li>使用 EXPLAIN 查看查询的执行计划，确认查询是从记录较少的表开始的，并检查索引的使用情况</li><li>在 ORDER BY … LIMIT … 的查询中，应该优先处理排序的表，这样可以减少排序和截取结果的开销</li></ul><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><ul><li>A 原子性: 事务是不可分割的最小单位, 要么全部成功, 要么全部失败</li><li>C 一致性: 事务完成时, 必须使所有的数据都保持一致状态</li><li>I 隔离性: 数据库系统提供的隔离机制, 保证事务在不收外部并发操作的影响的独立环境下运行</li><li>D 持久性: 事务一旦提交或回滚, 它对数据库的改变是永久的</li></ul><h2 id="并发事务带来了哪些问题"><a href="#并发事务带来了哪些问题" class="headerlink" title="并发事务带来了哪些问题"></a>并发事务带来了哪些问题</h2><ul><li>脏读</li><li>不可重复度</li><li>幻读: 一个事务按照条件查询, 没有对应的记录, 但是插入的时候发现记录已存在, 好像出现了幻影</li></ul><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><ul><li>多版本并发控制, 主要是通过隐藏字段(事务 id, roll_pointer), undo log 版本链和 ReadView组成的</li><li>它维护了一条数据的多个版本, 用 roll_pointer 进行连接, 形成一个 undo log 链</li><li>ReadView 快照读<ul><li>读已提交: 每次 select 都会生成快照</li><li>可重复读: 第一次 select 生成快照, 之后复用</li></ul></li></ul><p>对于一个事务视图来说, 除了自己更新总是可见的以外, 还有 3 种情况</p><ul><li>版本未提交, 不可见</li><li>版本已提交, 但是在视图创建后提交的, 不可见</li><li>版本已提交, 而且实在视图创建前提交的, 可见</li></ul><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>当同一个查询在不同的时间产生不同的结果集时, 事务中就会出现所谓的幻象, 例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>在 T1 时刻和 T2 时刻分别执行以下语句, 得到的结果集是不相同的<br>例如 T1 时刻有 5 条记录, 而 T2 时刻有 6 条记录<br>在可重复度级别下<br><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240514195706.png" alt="image.png"><br>前后两次查询结果是一样的, 没有出现幻读, 因为在可重复度级别下 select 执行的时候会创建一个快照, 在快照上读肯定没有幻读<br>但是当前读会出现幻读, 因为当前读都会查询最新版本数据, 然后再做进一步操作</p><ul><li>update</li><li>insert</li><li>delete</li><li>select … for update 都是当前读<br>我们假设 select … for update 是不会加锁, (实际上是会加锁的)<br><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240514195938.png" alt="image.png"><br>由于 select … for update 是当前读, 所以就会出现两次查询结果不一样的情况<br>所以 InnoDB 为了解决可重复读使用当前读而造成的幻读问题, 引入了间歇锁<br><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240514200205.png" alt="image.png"><br>事务 A 执行语句后就会在 id 范围为(2, +∞] 的 next-key lock(间歇锁 + 记录锁)<br>事务 B 在执行插入语句的时候, 判断插入位置被 A 加上了 next-key lock, 于是事务 B 会生成一个插入意向锁, 等待</li></ul><p>还有几种情况<br>详见小林 coding <a href="https://xiaolincoding.com/mysql/transaction/phantom.html">https://xiaolincoding.com/mysql/transaction/phantom.html</a></p><h2 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h2><ul><li>核心是 binlog 日志</li><li>从库读取主库的 binlog, 写入到从库的中继日志 Relay Log 中</li><li>从库执行中继日志的事务, 同步数据</li></ul><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><ul><li>水平分库</li><li>水平分表</li><li>垂直分库</li><li>垂直分表: 冷热数据分离, 多表互不影响(把表中某些字段分出去)</li></ul><h2 id="范围查找流程"><a href="#范围查找流程" class="headerlink" title="范围查找流程"></a>范围查找流程</h2><h3 id="有索引"><a href="#有索引" class="headerlink" title="有索引"></a>有索引</h3><p>比如找到 id &gt;&#x3D; 20 and &lt; 49的数据<br>1、加载根数据页到内存<br>2、在内存中做二分，找到对应的子页<br>3、在子页做二分，找到对应的子页<br>4、现在到了叶子节点页，在页中做二分，找到第一条满足的数据，这里是 id &#x3D; 20<br>5、一直通过叶子节点的链表指针，找到第一条不满足的为止，这里是 id &#x3D; 49<br>6、结束查找，返回数据</p><h3 id="没有索引"><a href="#没有索引" class="headerlink" title="没有索引"></a>没有索引</h3><ul><li>扫描全表</li></ul><h2 id="如何避免主从延迟"><a href="#如何避免主从延迟" class="headerlink" title="如何避免主从延迟"></a>如何避免主从延迟</h2><ul><li>强制将读请求路由到主库处理, 对于必须获取最新数据的请求, 都交给主库处理</li><li>延迟读取, 对于一些对数据比较敏感的场景, 可以在完成写请求之后, 避免立刻进行请求操作<ul><li>比如支付成功之后, 跳转到支付成功的页面, 当点击返回的时候才返回自己的账户</li></ul></li></ul><h2 id="MySQL-主键自增策略"><a href="#MySQL-主键自增策略" class="headerlink" title="MySQL 主键自增策略"></a>MySQL 主键自增策略</h2><ul><li>自增</li><li>UUID</li><li>雪花算法</li></ul><h2 id="MySQL-的索引类型"><a href="#MySQL-的索引类型" class="headerlink" title="MySQL 的索引类型"></a>MySQL 的索引类型</h2><ul><li>普通索引</li><li>唯一索引</li><li>主键索引, 一般在创建表的时候指定</li><li>联合索引</li><li>全文索引</li></ul><h2 id="间隙锁导致死锁"><a href="#间隙锁导致死锁" class="headerlink" title="间隙锁导致死锁"></a>间隙锁导致死锁</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务A</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> course <span class="hljs-keyword">where</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> course(id, user_id, <span class="hljs-keyword">no</span>) <span class="hljs-keyword">VALUE</span> (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;3&#x27;</span>);<br><br><span class="hljs-comment">-- 事务B</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> course <span class="hljs-keyword">where</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> course(id, user_id, <span class="hljs-keyword">no</span>) <span class="hljs-keyword">VALUE</span> (<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;4&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="日志有哪些"><a href="#日志有哪些" class="headerlink" title="日志有哪些"></a>日志有哪些</h2><ul><li>BinLog 日志</li><li>慢查询日志</li><li>Relay Log</li><li>Undo Log</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2024/05/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/05/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="Runnable-和-Callable-有什么区别"><a href="#Runnable-和-Callable-有什么区别" class="headerlink" title="Runnable 和 Callable 有什么区别"></a>Runnable 和 Callable 有什么区别</h2><ul><li>Runnable 的 run 方法没有返回值, Callable 的 call 方法有</li><li>Callable 的 call 方法是个泛型</li><li>Runnable 的 run 方法不能抛异常, Callable 的 call 方法可以</li></ul><h2 id="wait-和-sleep-方法有什么区别"><a href="#wait-和-sleep-方法有什么区别" class="headerlink" title="wait 和 sleep 方法有什么区别"></a>wait 和 sleep 方法有什么区别</h2><ul><li>归属不同: wait 方法是 Object 类中的, sleep 方法是 Thread 的静态方法</li><li>醒来时机不同: sleep(long) 和 wait(long) 都会在等待相应毫秒后醒来, wait 方法可以被 notify 唤醒</li><li>锁特性不同: wait 方法必须配合Synchronized 使用, sleep 无此限制<ul><li>wait 方法执行后会释放锁对象, 允许其他线程获得锁(我放弃 CPU, 你们可以用)</li><li>sleep 如果在 Synchronized 代码块中执行, 不会释放锁对象(我放弃 CPU, 你们也不能用)</li></ul></li></ul><h2 id="Synchronized-底层原理"><a href="#Synchronized-底层原理" class="headerlink" title="Synchronized 底层原理"></a>Synchronized 底层原理</h2><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><ul><li>在 1.7 版本中 ConcurrentHashMap 是用 数组 + 链表的数据结构实现的<ul><li>数组又分大数组 Segment 和小数组 HashEntry (大数组可以理解为 MySQL 的数据库, 小数组可以理解为表, 每个数组可以存储多条数据, 用链表连接)</li><li>它是基于 ReentrantLock 实现加锁和释放锁的操作, 锁的粒度为 Segment</li></ul></li><li>在 1.8 版本中用的是 数组 + 链表 + 红黑树的数据结构实现的<ul><li>用的是 CAS + volatile 或 Synchronized 方式保证线程安全</li><li>添加元素首先会判断容器是否为空, 如果为空则用 volatile + CAS 初始化</li><li>容器不为空则根据存储的元素计算位置是否为空, 为空用 CAS 设置节点</li><li>不为空则使用 Synchronized 加锁</li></ul></li></ul><h2 id="JMM-内存结构"><a href="#JMM-内存结构" class="headerlink" title="JMM 内存结构"></a>JMM 内存结构</h2><h2 id="介绍一下volatile-关键字"><a href="#介绍一下volatile-关键字" class="headerlink" title="介绍一下volatile 关键字"></a>介绍一下volatile 关键字</h2><ul><li>是用来修饰变量的</li><li>被其修饰的变量在修改后可以立即同步到主内存, 每次使用之前都是从主内存读取, 因此 volatile 可以保证可见性</li><li>volatile 可以禁止指令重排序, 被 volatile 修饰的变量操作, 会严格按照代码顺序执行</li></ul><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><ul><li>抽象队列同步器</li><li>内部维护了一个先进先出的双向队列, 队列中存储的是排队的线程</li><li>AQS 内部有一个属性 state, 相当于资源, 默认是 0, 当有一个线程成功修改 state 为 1, 则当前线程就等于获取了资源</li><li>对 state 修改的时候用 CAS 操作, 保证多个线程修改情况下的原子性</li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h2 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h2><h2 id="用线程池有什么好处"><a href="#用线程池有什么好处" class="headerlink" title="用线程池有什么好处"></a>用线程池有什么好处</h2><ul><li>不用反复创建收回线程所需要的资源</li><li>系统的响应速度更快</li><li>更加合理利用 CPU 资源</li><li>可以统一管理资源</li></ul><h2 id="线程池的创建方法"><a href="#线程池的创建方法" class="headerlink" title="线程池的创建方法"></a>线程池的创建方法</h2><ul><li>ThreadPoolExecutor 构造函数</li><li>Executors 工具类</li></ul><h2 id="什么时候使用线程池"><a href="#什么时候使用线程池" class="headerlink" title="什么时候使用线程池"></a>什么时候使用线程池</h2><ul><li>当需要频繁创建和销毁线程的时候</li><li>常量池的参数配置<ul><li>快速响应用户请求, 用户发起试试请求, 服务追求响应时间, 比如一个用户要查看商品信息, 那么响应越快越好, 所以这种场景不应该设置队列去缓存并发任务, 调高 corePoolSize 和 maxPoolSize 尽可能创造多的线程执行任务</li><li>批处理操作, 离线计算大量任务, 比如统计报表, 这种情况下, 任务量巨大不需要瞬时完成, 也就是吞吐量优先, 所以应该设置队列去缓冲并发任务</li></ul></li></ul><h2 id="notify-和-wait"><a href="#notify-和-wait" class="headerlink" title="notify 和 wait"></a>notify 和 wait</h2><ul><li>wait 和 notify 均依赖于锁, 且锁的对象必须是同一个对象, 否则无法执行唤醒</li><li>notify 唤醒是随机唤醒一个线程, 唤醒的范为是同一锁对象, 所有 wait 的线程</li></ul><p>notify 同一依赖于锁, 必须在同步快中执行, 执行之后会立刻释放锁吗?</p><ul><li>notify 在执行后不会立即唤醒, 而是等到 notify 同步块执行完之后才会去执行唤醒</li></ul><h2 id="wait-notify-和-await-signal-关系"><a href="#wait-notify-和-await-signal-关系" class="headerlink" title="wait&#x2F;notify 和 await&#x2F;signal 关系"></a>wait&#x2F;notify 和 await&#x2F;signal 关系</h2><ul><li>wait&#x2F;notify <ul><li>基于 Synchronized 实现的</li><li>无法控制唤醒谁, 随机唤醒</li></ul></li><li>await&#x2F;signal <ul><li>基于 Lock 实现的</li><li>使用 Condition 对象可以细粒度低控制线程的等待和唤醒</li></ul></li></ul><h2 id="Executors-工具类提供的四个线程池子"><a href="#Executors-工具类提供的四个线程池子" class="headerlink" title="Executors 工具类提供的四个线程池子"></a>Executors 工具类提供的四个线程池子</h2><ul><li><code>newSingleThreadExecutor()</code> 用于需要保证任务按顺序执行的场景<ul><li>corePoolSize: 1</li><li>maximumPoolSize: 1</li><li>阻塞队列: LinkedBlockingQueue 大小是 Integer.MAX_VALUE</li></ul></li><li><code>newFixedThreadPool(int nThreads)</code> 用于负载稳定、任务量恒定的场景<ul><li>corePoolSize: nThreads</li><li>maximumPoolSize: nThreads</li><li>阻塞队列: LinkedBlockingQueue 大小是 Integer.MAX_VALUE</li></ul></li><li><code>newCachedThreadPool()</code> 适用于执行大量短期异步任务的场景，能高效地利用系统资源<ul><li>corePoolSize: 0</li><li>maximumPoolSize: Integer.MAX_VALUE</li><li>阻塞队列: 大小为 0</li></ul></li><li><code>ScheduledThreadPoolExecutor(int corePoolSize)</code> 用于需要定时或周期性执行任务的场景<ul><li>corePoolSize: 0</li><li>maximumPoolSize: Integer.MAX_VALUE</li><li>阻塞队列: 大小无界, 按照延迟的时间长短对任务进行排序</li></ul></li></ul><h2 id="shutdown-和-shutdownNow"><a href="#shutdown-和-shutdownNow" class="headerlink" title="shutdown() 和 shutdownNow()"></a>shutdown() 和 shutdownNow()</h2><ul><li>shutdown(): 关闭线程池, 线程池的状态变为 SHUTDOWN, 线程池不再接受新任务, 但是队列里的任务得执行完毕</li><li>shutdownNow(): 关闭线程池, 线程池的状态变为 STOP, 线程池会终止当前正在运行的任务, 并停止处理排队的任务并返回正在等待执行的 List</li></ul><h2 id="isTerminated-和-isShutdown"><a href="#isTerminated-和-isShutdown" class="headerlink" title="isTerminated() 和 isShutdown()"></a>isTerminated() 和 isShutdown()</h2><ul><li>isShutdown(): 当调用 shutdown() 方法后返回 true</li><li>isTerminated: 当调用 shutdown() 方法后, 并执行完所有提交的任务后返回 true</li></ul><h2 id="如何正确使用线程池"><a href="#如何正确使用线程池" class="headerlink" title="如何正确使用线程池"></a>如何正确使用线程池</h2><ul><li>正确声明线程池, 用 ThreadExecutorPool 构造函数声明, 而不是 Executors 工具类(会有 OOM 的风险)</li><li>监测线程池运行状态, SpringBoot 的 Actuator 组件</li><li>建议不同业务使用不同的线程池</li><li>给线程池命名</li><li>别忘记关闭线程池</li><li>线程池尽量不要放耗时任务, 耗时任务用消息队列异步执行</li></ul><h2 id="动态调整线程池大小-美团"><a href="#动态调整线程池大小-美团" class="headerlink" title="动态调整线程池大小(美团)"></a>动态调整线程池大小(美团)</h2><ul><li>用 setCorePoolSize 调整核心线程池大小</li><li>用 setMaximumPoolSize 调整最大线程池大小</li><li>重写 LinkedBlockingQueue, 把里面的 capacity 字段的 final关键字去掉, 变为可变的</li></ul><h2 id="动态调整线程池大小-Nacos"><a href="#动态调整线程池大小-Nacos" class="headerlink" title="动态调整线程池大小(Nacos)"></a>动态调整线程池大小(Nacos)</h2><ul><li><code>@RefreshScope</code> 支持 Nacos 动态刷新</li><li><code>@Value(&quot;$&#123;max.size&#125;&quot;</code> 读取在 Nacos 配置的具体信息</li><li>配置监听, Nacos 配置变更时实时修改线程池配置</li></ul><h2 id="线程池中线程异常后-销毁还是复用"><a href="#线程池中线程异常后-销毁还是复用" class="headerlink" title="线程池中线程异常后, 销毁还是复用?"></a>线程池中线程异常后, 销毁还是复用?</h2><ul><li>使用 execute() 提交任务<ul><li>如果异常没有在任务内捕获, 那么该异常会导致当前线程终止, 控制台打印日志</li><li>线程池会检测到这种异常终止, 并创建一个新的线程来替换它, 从而保证配置的线程数不变</li></ul></li><li>使用 submit() 提交任务<ul><li>如果在执行中发生异常, 会封装在 submit() 返回的 <code>Future</code> 对象中</li><li>当调用 <code>Future.get()</code> 方法可以捕获到一个 <code>ExecutionException</code> </li><li>线程不会因异常终止, 会继续存在线程池中</li></ul></li></ul><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><ul><li>是用来做多个任务的编排的, 规定任务前后执行顺序</li><li>Future 不支持异步任务的编排, 获取计算结果的 <code>get()</code> 方法为阻塞调用</li></ul><h2 id="Java-不同锁的实现和使用场景"><a href="#Java-不同锁的实现和使用场景" class="headerlink" title="Java 不同锁的实现和使用场景"></a>Java 不同锁的实现和使用场景</h2><ul><li><code>synchronized</code> 关键字<ul><li>可重入锁</li><li>非公平锁</li></ul></li><li><code>ReentrantLock</code><ul><li>可重入锁</li><li>AQS 队列</li><li>可以实现公平锁</li></ul></li><li><code>ReadWrite Lock</code> 读写锁<ul><li>读锁是共享锁, 读读不互斥, 获取到读锁的时候, 无法获取写锁</li><li>写锁是独占锁, 加上写锁的时候别的线程读写都不行</li></ul></li></ul><h2 id="CountDownLatch-类-倒计时器"><a href="#CountDownLatch-类-倒计时器" class="headerlink" title="CountDownLatch 类(倒计时器)"></a>CountDownLatch 类(倒计时器)</h2><ul><li>CountDownLatch 允许 count 个线程阻塞在一个地方, 直至所有线程的任务都执行完毕</li><li>典型用法<ul><li>某一个线程在开始运行前等待 n 个线程执行完毕: 将 CountDownLatch 的计数器初始化为 n, 每当一个任务线程执行完毕, 就将计数器 -1, 当计数器的值变为 0 时, 在 CountDownLatch 上 await() 的线程就被唤醒<ul><li>典型应用场景就是启动一个服务时, 主线程需要等待多个组件加载完成, 之后再继续执行</li></ul></li><li>实现多个线程开始执行任务的最大并发性: 强调的是多个线程在某一时刻同时开始执行, 类似于赛跑, 将多个线程放到起点, 同时开跑, 初始化一个共享的 CountDownLatch 对象, 将其计数器初始化为 1, 多个线程在开始执行任务前首先 <code>countdownLathch.await()</code> 当主线程调用 countDown() 时, 计数器变为 0, 多个线程被同时唤醒</li></ul></li></ul><h2 id="如何预防死锁"><a href="#如何预防死锁" class="headerlink" title="如何预防死锁"></a>如何预防死锁</h2><ul><li>破坏请求与保持条件: 一次性申请所有资源</li><li>破坏不可剥夺条件: 占用部分资源的线程去申请其他资源时, 如果申请不到, 主动释放他所占用的资源</li><li>破坏循环等待条件: 按照顺序申请资源, 释放资源反序释放</li></ul><h2 id="java-多线程通信"><a href="#java-多线程通信" class="headerlink" title="java 多线程通信"></a>java 多线程通信</h2><ul><li>锁</li><li><code>wait/notify</code></li><li><code>volatile</code> </li><li>管道</li><li><code>join</code></li><li><code>ThreadLocal</code></li></ul><h2 id="如何检测死锁"><a href="#如何检测死锁" class="headerlink" title="如何检测死锁"></a>如何检测死锁</h2><ul><li><code>jstack</code> 命令可以查看 JVM 线程栈和堆内存的情况, 如果有死锁, 通常会输出 <code>Found one Java-level deadlock</code> 字样</li><li>实际项目可以用 <code>top</code> 查看 CPU 占用情况, 出现死锁会导致 CPU 内存占用过高</li></ul><h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><ul><li>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang</title>
    <link href="/2024/05/26/golang/"/>
    <url>/2024/05/26/golang/</url>
    
    <content type="html"><![CDATA[<h1 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h1><h2 id="init-和-mian-函数"><a href="#init-和-mian-函数" class="headerlink" title="init 和 mian 函数"></a>init 和 mian 函数</h2><ul><li>init 函数<ul><li>同一个 package 可以定义多个 init 方法<ul><li>同一个 package 不同文件 init 方法执行按照文件名先后顺序执行</li></ul></li><li>同一个 go 文件中可以重复定义 init 方法<ul><li>按定义顺序执行</li></ul></li><li>按照 import 顺序调用其他包的 init 函数</li><li>导入顺序 mian -&gt; A -&gt; B -&gt; C 则 init 执行的顺序正好相反</li><li>init 函数都在一个 goroutine 内执行</li><li>执行完之后再执行 main 函数<br>  <img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240523190103.png" alt="image.png"></li></ul></li></ul><h2 id="byte-和-rune-有什么区别"><a href="#byte-和-rune-有什么区别" class="headerlink" title="byte 和 rune 有什么区别"></a>byte 和 rune 有什么区别</h2><ul><li>都是字符类型, 都是别名类型</li><li>byte 本质是 uint8 类型的别名, 代表了 ASCII 码的一个字符</li><li>rune 本质是 int32 类型的别名, 代表了 UTF-8 字符</li></ul><h2 id="Go-struct-能不能比较"><a href="#Go-struct-能不能比较" class="headerlink" title="Go struct 能不能比较"></a>Go struct 能不能比较</h2><ul><li>如果 struct 有不能比较的字段, 就不能比较</li><li>只能比较是否相等, 不能比较大小</li><li>所有属性都相等并且顺序一致的 struct 才能比较</li></ul><h2 id="goroutine-和线程的区别"><a href="#goroutine-和线程的区别" class="headerlink" title="goroutine 和线程的区别"></a>goroutine 和线程的区别</h2><ul><li>内存占用<ul><li>goroutine 栈内存消耗为 2KB</li><li>Thread 消耗 1MB</li></ul></li><li>创建和销毁<ul><li>Thread 创建和销毁都是操作系统内核级别的, 通常由线程池管理</li><li>goroutine 由 Go runtime 负责创建, 创建销毁消耗非常小, 是用户级</li></ul></li><li>切换<ul><li>Thread 切换时, 需要保存各种寄存器</li><li>goroutine 切换只需要保存 3 个寄存器 <ul><li><code>PC 程序计数器</code></li><li><code>Stack Pointer 栈顶指针</code></li><li><code>BP 基址指针</code></li></ul></li></ul></li></ul><h2 id="slice-和数组的区别"><a href="#slice-和数组的区别" class="headerlink" title="slice 和数组的区别"></a>slice 和数组的区别</h2><ul><li>slice 的底层数据结构是数组</li><li>数组是定长的, slice 可以扩容</li><li>数组就是一片连续的内存, slice 实际上是一个结构体, 包含长度, 容量, 底层数组<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span>&#123;<br>array unsafe.Pointer <span class="hljs-comment">// 元素指针</span><br><span class="hljs-built_in">len</span> <span class="hljs-type">int</span> <span class="hljs-comment">// 数组长度</span><br><span class="hljs-built_in">cap</span> <span class="hljs-type">int</span> <span class="hljs-comment">// 容量</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>底层数据可以被多个 slice 指向, 所以对一个 slice 操作有可能影响其他 slice</li></ul><h2 id="map-实现原理"><a href="#map-实现原理" class="headerlink" title="map 实现原理"></a>map 实现原理</h2><ul><li>数据被放入一个由桶组成的有序数组中, 每个桶最多可以存放 8 个 <code>key/value</code> 对</li><li>key 的 Hash 值低位用于在该数组中定位到桶, 高 8 位用于在桶中区分 <code>key/value</code> 对</li><li>超了会链接到额外的溢出桶 <code>overflow uintptr</code> 所以数据结构为<ul><li>hash 数组</li><li>桶内 key-value 数组</li><li>溢出的桶链表</li></ul></li><li>当 Hash 超过阈值需要扩容时, 会分配一个新的桶数组, 一般是旧的 2 倍</li><li>go 不会一次全量拷贝, 耗时太大, 会在每次读写 map 的时候动态迁移</li></ul><h2 id="为什么会-Hash-冲突"><a href="#为什么会-Hash-冲突" class="headerlink" title="为什么会 Hash 冲突"></a>为什么会 Hash 冲突</h2><ul><li>通过哈希函数产生的哈希值是有限的, 数据可能比较多, 导致经过哈希函数处理后出现相同的哈希值</li></ul><h2 id="go-map-并发导致-panic-如何解决"><a href="#go-map-并发导致-panic-如何解决" class="headerlink" title="go map 并发导致 panic 如何解决"></a>go map 并发导致 panic 如何解决</h2><ul><li>go 中 map 不支持并发读写</li><li>使用 <code>sync.map</code></li></ul><h2 id="go-的垃圾回收"><a href="#go-的垃圾回收" class="headerlink" title="go 的垃圾回收"></a>go 的垃圾回收</h2><ul><li>无分代</li><li>不整理(回收过程中不对对象进行移动与整理)</li><li>并发(与用户代码并发执行)</li><li>三色标记清除法</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
