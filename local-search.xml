<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redission tryLock</title>
    <link href="/2024/05/28/Redission-tryLock/"/>
    <url>/2024/05/28/Redission-tryLock/</url>
    
    <content type="html"><![CDATA[<h1 id="Redisson-的-tryLock"><a href="#Redisson-的-tryLock" class="headerlink" title="Redisson 的 tryLock"></a>Redisson 的 tryLock</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit)</span><br></code></pre></td></tr></table></figure><p>在 waitTime 时间范围内尝试获取锁, 如果获取到锁, 设置过期时间 leaseTime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonLock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RedissonBaseLock</span> &#123;<br>    <span class="hljs-comment">// 在waitTime时间范围内尝试获取锁，如果获取到锁，则设置锁过期时间leaseTime</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> unit.toMillis(waitTime);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-comment">// 第一步：尝试获取锁</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">ttl</span> <span class="hljs-operator">=</span> tryAcquire(waitTime, leaseTime, unit, threadId);<br>        <span class="hljs-comment">// ttl为空说明获取到了锁</span><br>        <span class="hljs-keyword">if</span> (ttl == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 判断尝试获取锁是否超过waitTime</span><br>        time -= System.currentTimeMillis() - current;<br>        <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>) &#123;<br>            acquireFailed(waitTime, unit, threadId);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 第二步：订阅解锁消息通知</span><br>        current = System.currentTimeMillis();<br>        <span class="hljs-comment">// 订阅锁释放</span><br>        RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);<br>        <span class="hljs-comment">// 等待锁释放消息，等待时间超过waitTime，获取锁失败</span><br>        <span class="hljs-keyword">if</span> (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) &#123;<br>            <span class="hljs-comment">// 如果订阅解锁Future在执行中，等任务执行完后取消订阅锁释放</span><br>            <span class="hljs-keyword">if</span> (!subscribeFuture.cancel(<span class="hljs-literal">false</span>)) &#123;<br>                subscribeFuture.onComplete((res, e) -&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">// 取消订阅解锁通知</span><br>                        unsubscribe(subscribeFuture, threadId);<br>                    &#125;<br>                &#125;);<br>            &#125;<br>            acquireFailed(waitTime, unit, threadId);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 判断尝试获取锁是否超过waitTime</span><br>            time -= System.currentTimeMillis() - current;<br>            <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>) &#123;<br>                acquireFailed(waitTime, unit, threadId);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        <br>            <span class="hljs-comment">// 第三步：自旋尝试获取锁</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>                <span class="hljs-comment">// 1、尝试获取锁(下文会详细解析此方法)</span><br>                ttl = tryAcquire(waitTime, leaseTime, unit, threadId);<br>                <span class="hljs-comment">// ttl为空说明获取到了锁</span><br>                <span class="hljs-keyword">if</span> (ttl == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 判断尝试获取锁是否超过waitTime</span><br>                time -= System.currentTimeMillis() - currentTime;<br>                <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>) &#123;<br>                    acquireFailed(waitTime, unit, threadId);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 等待锁释放（信号量控制）</span><br>                currentTime = System.currentTimeMillis();<br>                <span class="hljs-keyword">if</span> (ttl &gt;= <span class="hljs-number">0</span> &amp;&amp; ttl &lt; time) &#123;<br>                    <span class="hljs-comment">// 尝试获取信号量</span><br>                    subscribeFuture.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    subscribeFuture.getNow().getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);<br>                &#125;<br><br>                <span class="hljs-comment">// 判断尝试获取锁是否超过waitTime</span><br>                time -= System.currentTimeMillis() - currentTime;<br>                <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>) &#123;<br>                    acquireFailed(waitTime, unit, threadId);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 第四步：取消解锁订阅</span><br>            unsubscribe(subscribeFuture, threadId);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要分为以下四步</p><ul><li>tryAcquire 尝试获取锁, 获取到返回 true</li><li>获取不到说明锁被占用了, 订阅结果消息通知</li><li>收到消息解锁通知, 自旋获取锁, 直到 waitTime 获取锁失败</li><li>不论是否获取锁成功, 取消解锁消息订阅</li></ul><p>tryAcquire 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Long <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId)</span> &#123;<br>    <span class="hljs-keyword">return</span> get(tryAcquireAsync(waitTime, leaseTime, unit, threadId));<br>&#125;<br><br><span class="hljs-keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="hljs-title function_">tryAcquireAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId)</span> &#123;<br>    RFuture&lt;Long&gt; ttlRemainingFuture;<br>    <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1</span>) &#123;<br>        ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 这里需要注意的是leaseTime == -1，会触发redisson看门狗机制</span><br>        ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,<br>                TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);<br>    &#125;<br>    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取锁成功</span><br>        <span class="hljs-keyword">if</span> (ttlRemaining == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1</span>) &#123;<br>                internalLockLeaseTime = unit.toMillis(leaseTime);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 锁自动续时（看门狗机制）触发条件leaseTime == -1</span><br>                scheduleExpirationRenewal(threadId);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> ttlRemainingFuture;<br>&#125;<br></code></pre></td></tr></table></figure><p>tryLockInnerAsync 里面是尝试获取分布式锁的 lua 脚本<br>scheduleExpirationRenewal 锁自动续时, 看门狗机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T&gt; RFuture&lt;T&gt; <span class="hljs-title function_">tryLockInnerAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> &#123;<br>    <span class="hljs-keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,<br>            <span class="hljs-comment">// 如果key一开始就不存在，则直接创建一个key</span><br>            <span class="hljs-string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +<br>                    <span class="hljs-string">&quot;return nil; &quot;</span> +<br>                    <span class="hljs-string">&quot;end; &quot;</span> +<br>                    <span class="hljs-comment">// 这里是重入锁的实现，同一个线程多次获取锁只需要在value加1即可，value相当于一个加锁计数器</span><br>                    <span class="hljs-string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +<br>                    <span class="hljs-string">&quot;return nil; &quot;</span> +<br>                    <span class="hljs-string">&quot;end; &quot;</span> +<br>                    <span class="hljs-comment">// 有其他线程持有锁，加锁失败，返回锁过期时间</span><br>                    <span class="hljs-string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,<br>            Collections.singletonList(getRawName()), unit.toMillis(leaseTime), getLockName(threadId));<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>加锁的 key 不存在就创建一个 redis hash key, field(当前线程 id), value(加锁次数)</li><li>有线程持有锁并且未解锁, 其他线程无法获取到锁</li><li>加锁成功返回 null, 加锁失败返回过期时间</li></ol><p>锁过期时间自动续费</p><ol><li>锁过期自动续费的触发条件为 tryLock 设置的锁到期时间为-1</li><li>自动续费的原理是创建一个定时任务, 每 internalLockLeaseTime &#x2F; 3 时触发一次, 如果发现持有锁未释放, 把锁过期时间更新为 internalLockLeaseTime(默认为 30s)</li><li>锁过期时间更新后, 再次递归调用 renewExpiration 创建下一次定时任务</li></ol><p>前面 tryLock 方法的订阅解锁消息通知是在 unlock 的时候发起的<br>unlockAsync 方法内部调用 lua 脚本, 调用 publish 推送解锁消息</p><p>Redis 的 publish</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs redis">publish channel message<br></code></pre></td></tr></table></figure><ul><li>channel 指定要发布消息的频道</li><li>message 要发布的消息内容<br>在 tryLock 和 unLock 中, 他们的 channel 是线程 id</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2024/05/28/Spring/"/>
    <url>/2024/05/28/Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h2><ul><li>通过 BeanDefinition 获取 Bean 的定义信息</li><li>通过构造函数实例化 Bean</li><li>Bean 的依赖注入</li><li>处理 Aware 接口</li><li>BeanPostProcessor - 前置方法</li><li>初始化方法(InitializingBean, init-method)</li><li>BeanPostProcessor - 后置方法</li><li>销毁 Bean</li></ul><p>BeanDefinition 是 Spring 容器在进行实例化时, 会将 xml 配置的 <code>&lt;bean&gt;</code> 信息封装成一个 BeanDefinition 对象, Spring 根据它来创建 Bean 对象<br><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240305171200.png" alt="image.png"></p><h2 id="Aware-接口有什么用"><a href="#Aware-接口有什么用" class="headerlink" title="Aware 接口有什么用"></a>Aware 接口有什么用</h2><ul><li>通过实现特定的 Aware 接口, bean 可以获得对 Spring 容器的某些部分(如配置文件, 文件资源, 环境属性等) 的访问权</li><li>ApplicationContextAware: 允许一个 bean 获得对 ApplicationContext 的访问, 意味着该 bean 可以访问 Spring 容器的所有配置信息的定义</li><li>BeanNameAware: 它会在创建过程中接收到自己在容器中的名称</li><li>BeanFactoryAware: Bean 可以直接访问到它所在的 BeanFactory, 从而允许请求其他 Bean 等操作</li><li>实现这些接口可以让不是在 Spring 的环境下, 获取 Spring 的 Bean, 例如通过 BeanFactory</li></ul><h2 id="InitializingBean-有什么作用"><a href="#InitializingBean-有什么作用" class="headerlink" title="InitializingBean 有什么作用"></a>InitializingBean 有什么作用</h2><ul><li>用于在初始化方法完成后执行自定义初始化逻辑</li><li>当一个 Bean 实现了 InitializingBean 接口时, Spring 容器在初始化Bean 并完成所有属性设置后会调用 <code>afterPropertiesSet()</code> 方法来执行额外初始化操作</li></ul><h2 id="Spring-出现循环依赖"><a href="#Spring-出现循环依赖" class="headerlink" title="Spring 出现循环依赖"></a>Spring 出现循环依赖</h2><ul><li>循环依赖是指两个或多个 Bean 相互依赖, A 依赖于 B, B 依赖于 A</li></ul><h3 id="构造器注入循环依赖能解决吗"><a href="#构造器注入循环依赖能解决吗" class="headerlink" title="构造器注入循环依赖能解决吗"></a>构造器注入循环依赖能解决吗</h3><ul><li>如果 A 和 B 都用构造器注入不行, 因为在创建 Bean 实例时需要调用构造函数创建 Bean</li><li>但是一个使用 Setter 注入, 一个使用构造器注入需要分情况考虑<ul><li>A 用 Setter 注入 B, B 用构造器注入 A, 可以解决循环依赖</li><li>A 用构造器注入 B, B 用 Setter 注入 A, 不可以解决</li><li>因为 Spring 在创建 Bean 的时候默认是按照自然排序进行创建, A 会优先于 B 创建</li></ul></li></ul><h2 id="Spring-创建-Bean-简单的三步"><a href="#Spring-创建-Bean-简单的三步" class="headerlink" title="Spring 创建 Bean 简单的三步"></a>Spring 创建 Bean 简单的三步</h2><ul><li>实例化: 对应方法 <code>AbstractAutowireCapableBeanFactory</code> 的 <code>createBeanInstance</code> 方法</li><li>属性注入: 对应方法 <code>AbstractAutowireCapableBeanFactory</code> 的 <code>populateBean</code> 方法</li><li>初始化: 对应方法 <code>AbstractAutowireCapableBeanFactory</code> 的 <code>initializeBean</code><br>其实就是</li><li>实例化, new 了一个对象</li><li>属性注入: 为 new 的对象填充属性</li><li>初始化: 执行 aware 接口中的方法, 完成 AOP 代理</li></ul><h2 id="Spring-三级缓存"><a href="#Spring-三级缓存" class="headerlink" title="Spring 三级缓存"></a>Spring 三级缓存</h2><ul><li><code>singletonObjects</code> 一级缓存: 存储创建好的单例 Bean</li><li><code>earlySingletonObjects</code> 二级缓存: 完成实例化, 还未进行属性注入及初始化的对象</li><li><code>singletonFactories</code> 三级缓存: 提前暴露一个单例工厂, 二级缓存中存储的就是从这个工厂中获取的对象</li></ul><h2 id="SpringMVC-的执行流程"><a href="#SpringMVC-的执行流程" class="headerlink" title="SpringMVC 的执行流程"></a>SpringMVC 的执行流程</h2><ul><li>用户发送请求到前端控制器 DispatchServlet</li><li>DispatchServlet 收到请求, 调用 HandlerMapper</li><li>HandlerMapper 找到具体的处理器, 生成处理器对象及处理器拦截器(如果有) 一起返回 DispatchServlet</li><li>DispatchServlet 调用 HandlerAdapter(处理器适配器)</li><li>HandlerAdapter 调用具体的 Controller</li></ul><h2 id="SpringBoot-自动装配原理-or-启动流程"><a href="#SpringBoot-自动装配原理-or-启动流程" class="headerlink" title="SpringBoot 自动装配原理 or 启动流程"></a>SpringBoot 自动装配原理 or 启动流程</h2><ul><li>在 SpringBoot 启动类上有一个 <code>@SpringBootApplication</code> 注解, 其中封装了三个注解<ul><li><code>@SpringBootConfiguration</code></li><li><code>@EnableAutoConfiguration</code></li><li><code>@ComponentScan</code></li></ul></li><li>其中 <code>@EnableAutoConfiguration</code> 是实现自动配置的核心注解, 该注解通过 <code>@Import</code> 注解导入对应的配置选择器类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br></code></pre></td></tr></table></figure></li><li>配置选择器类内部读取该项目和该项目引用 jar 包的 classpath 路径下的 META-INF&#x2F;spring.factories 文件, 该文件里有所需要加载的类的全限定类名, 会根据 bean 的条件注解决定是否将其导入 Spring 容器中<ul><li>条件注解有像 <code>@ConditionalOnClass</code> 这样的注解, 表示有对应的 class 文件, 才加载</li></ul></li></ul><h2 id="SpringBoot-依赖管理"><a href="#SpringBoot-依赖管理" class="headerlink" title="SpringBoot 依赖管理"></a>SpringBoot 依赖管理</h2><ul><li>继承了 <code>spring-boot-starter-parent</code>  其又继承了 <code>spring-boot-dependencies</code> 内部定义了很多依赖</li></ul><h2 id="spring-boot-starter-跟-spring-boot-starter-web-有什么区别"><a href="#spring-boot-starter-跟-spring-boot-starter-web-有什么区别" class="headerlink" title="spring-boot-starter 跟 spring-boot-starter-web 有什么区别"></a>spring-boot-starter 跟 spring-boot-starter-web 有什么区别</h2><ul><li><code>spring-boot-starter</code> 是许多其他 Starter 的基础依赖, 但不包含任何特定的功能模块, 它包含以下内容<ul><li>Spring Core</li><li>Spring Context</li><li>Spring AOP</li></ul></li><li><code>spring-boot-starter-web</code> 是专门用于构建 Web 应用的 Starter 依赖, 能处理 HTTP 请求, 它里面包含 <code>spring-boot-starter</code> <ul><li>Spring Web</li><li>Spring MVC</li><li>Jackson</li><li>Tomcat</li></ul></li></ul><h2 id="Spring-常用的类"><a href="#Spring-常用的类" class="headerlink" title="Spring 常用的类"></a>Spring 常用的类</h2><ul><li><code>ApplicationContext</code> Spring 容器接口, 负责创建和管理 Spring Bean</li><li><code>BeanFactory</code> Spring 容器, 提供 Bean 的基础管理</li><li><code>BeanDefinition</code> </li><li><code>InitializingBean</code></li><li>一些 Aware 接口</li></ul><h2 id="Spring-自动注入原理"><a href="#Spring-自动注入原理" class="headerlink" title="Spring 自动注入原理"></a>Spring 自动注入原理</h2><ul><li>使用反射机制将依赖注入到 Bean 中<ul><li>构造器注入</li><li>Setter 方法注入</li><li>字段注入</li></ul></li></ul><h2 id="get-和-post-有什么区别"><a href="#get-和-post-有什么区别" class="headerlink" title="get 和 post 有什么区别"></a>get 和 post 有什么区别</h2><ul><li>get 参数拼接在 Url 后面, post 参数在请求体里, 相对安全</li><li>数据大小限制, get 受到 Url 长度的限制, post 理论上没有大小限制</li><li>幂等性, get 是幂等的, post 是非幂等的</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2024/05/27/MySQL/"/>
    <url>/2024/05/27/MySQL/</url>
    
    <content type="html"><![CDATA[<ul><li><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="redo-log-和-binlog-的区别"><a href="#redo-log-和-binlog-的区别" class="headerlink" title="redo log 和 binlog 的区别"></a>redo log 和 binlog 的区别</h2><ul><li>redo log 是 InnoDB 特有的, binlog 是 Server 层的每个数据引擎都有</li><li>redo log 记录的是物理日志, 记录的是在某个数据页做的修改, 比如”对 xxx 表中 yyy 数据页 zzz 偏移量的地方坐了 aaa 更新” binlog 是逻辑日志, 记录的是这个语句的原始逻辑, 比如”给 id &#x3D; 2 的字段 c 加 1”</li><li>redo log 是循环写的, 空间会用完, binlog 是追加写的</li></ul><h2 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a>聚簇索引和二级索引</h2><ul><li>InnoDB 使用了 B+ 树索引模型</li><li>主键索引的叶子节点存储的是整行数据, 在 InnoDB 中, 主键索引也被称为聚簇索引</li><li>非主键索引的叶子节点存储的是主键值, 在 InnoDB 中, 非主键索引也被称为二级索引</li></ul><h2 id="为什么用-B-树做索引"><a href="#为什么用-B-树做索引" class="headerlink" title="为什么用 B+ 树做索引"></a>为什么用 B+ 树做索引</h2><h3 id="什么样的数据结构是好的索引"><a href="#什么样的数据结构是好的索引" class="headerlink" title="什么样的数据结构是好的索引?"></a>什么样的数据结构是好的索引?</h3><ul><li>MySQL 是持久化到磁盘的, 因此当我们通过索引查找某行数据的时候, 需要先从磁盘读取索引到内存, 再通过索引从磁盘中找到某行数据, 然后读入内存, 也就是说查询的过程中会发生多次 IO 操作, IO 操作次数越多, 性能损耗越大</li><li>MySQL 是支持范围查找的, 所以索引数据不仅能高效查找某一个记录, 而且也要能高效执行范围查找</li><li>所以一个合适的索引要满足<ul><li>尽可能少的进行 IO 操作</li><li>能高效查找某一个记录, 也能高效进行范围查找</li></ul></li></ul><h3 id="各个数据结构对比"><a href="#各个数据结构对比" class="headerlink" title="各个数据结构对比"></a>各个数据结构对比</h3><ul><li>顺序结构, 可以用二分来查找, 速度快, 但是插入性能太低</li><li>二叉搜索树, 不支持范围查找, 而且有退化成链表的风险</li><li>平衡二叉树, 不支持范围查找, 并且由于是二叉树, 随着元素增多, 树的高度变高, 磁盘 IO 次数增加</li><li>B 树, B 树可以是多叉树, 但是每个节点都存储索引+数据, 而数据的大小可能远远超过索引大小</li><li>B+树, 叶子结点才会存放实际数据, 非叶子节点只会存放索引, 叶子节点构成一个有序链表</li></ul><h3 id="InnoDB-中的-B-树"><a href="#InnoDB-中的-B-树" class="headerlink" title="InnoDB 中的 B+ 树"></a>InnoDB 中的 B+ 树</h3><ul><li>叶子节点用双向链表进行连接, 既能向左遍历, 也能向右遍历</li><li>叶子节点内容是数据页, 数据页存放了数据以及各种信息, 每个数据页默认大小 16KB</li></ul><h2 id="什么是两阶段锁"><a href="#什么是两阶段锁" class="headerlink" title="什么是两阶段锁"></a>什么是两阶段锁</h2><ul><li>在 InnoDB 事务中, 行锁是在需要的时候加上的, 但并不是不需要了就立即释放, 而是等到事务结束才释放</li></ul><h2 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h2><ul><li>快照读中, 事务读取的是数据快照, 即事务开始时的数据状态</li><li>当前读中, 事务读取的是数据库当前数据状态, 即最新数据, 如果有锁的话阻塞等待</li><li>可重复读的隔离级别下<ul><li>select 默认快照读</li><li>select 加锁是当前读<ul><li>select a from t where id &#x3D; 1 lock in share mode 共享锁</li><li>select a from t where id for update 排他锁</li></ul></li><li>update 语句是当前读</li></ul></li></ul><h2 id="索引创建原则"><a href="#索引创建原则" class="headerlink" title="索引创建原则"></a>索引创建原则</h2><ul><li>数据量大, 且查询频繁的时候要创建索引</li><li>为常作为查询条件, 排序, 分组的字段创建索引</li><li>字段的内容区分度要高</li><li>内容较长的情况下, 使用前缀索引</li><li>尽量使用联合索引, 这样可以进行覆盖查询, 方式回表</li><li>要控制索引的数量</li></ul><h2 id="什么情况下索引会失效"><a href="#什么情况下索引会失效" class="headerlink" title="什么情况下索引会失效"></a>什么情况下索引会失效</h2><ul><li>联合索引中违反最左前缀法则</li><li>联合索引中范围查询的右边的列, 不能使用索引</li><li>索引列上进行运算操作, 索引失效</li><li>索引列进行类型转换, 比如字符串不加单引号, 索引失效</li><li>以%开头的 like 模糊查询, 索引失效</li></ul><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><ul><li>是一种快速搜索文本数据的索引, 适用于需要处理大量自然语言文本的应用场景</li><li>底层由倒排索引实现<ul><li>词典: 存储每一个词</li><li>倒排列表: 记录每个词在文档中出现的位置</li></ul></li></ul><h2 id="慢查询出现的原因"><a href="#慢查询出现的原因" class="headerlink" title="慢查询出现的原因"></a>慢查询出现的原因</h2><ul><li>没有使用索引或者索引不当</li><li>复杂的 join 操作, 尤其涉及大量数据的表</li><li>子查询过多</li><li>表结构设计不合理, 过多的冗余设计</li><li>数据量过大</li><li>服务器的硬件资源不粗</li></ul><h2 id="优化慢查询"><a href="#优化慢查询" class="headerlink" title="优化慢查询"></a>优化慢查询</h2><ul><li>先运行看看是否真的很慢，注意设置 SQL_NO_CACHE</li><li>WHERE 条件单表查，锁定最小返回记录表<ul><li>在涉及多个表的查询中，应该从返回记录最少的表开始查询，以减少数据处理的开销</li><li>对于单表查询，通过 WHERE 条件逐个应用到表中的每个字段，找出区分度最高的字段，这样可以更高效地过滤数据<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 假设有两个表</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> A, B <span class="hljs-keyword">WHERE</span> A.id <span class="hljs-operator">=</span> B.id <span class="hljs-keyword">AND</span> A.status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;active&#x27;</span> <span class="hljs-keyword">AND</span> B.type <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;premium&#x27;</span>;<br><span class="hljs-comment">-- 分析单标 where 条件效果</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> A <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;active&#x27;</span>; <span class="hljs-comment">-- 结果记录数较多</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> B <span class="hljs-keyword">WHERE</span> type <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;premium&#x27;</span>;  <span class="hljs-comment">-- 结果记录数较少</span><br><span class="hljs-comment">-- 优先从记录较少的 B 表开始查</span><br></code></pre></td></tr></table></figure></li></ul></li><li>使用 EXPLAIN 查看查询的执行计划，确认查询是从记录较少的表开始的，并检查索引的使用情况</li><li>在 ORDER BY … LIMIT … 的查询中，应该优先处理排序的表，这样可以减少排序和截取结果的开销</li></ul><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><ul><li>A 原子性: 事务是不可分割的最小单位, 要么全部成功, 要么全部失败</li><li>C 一致性: 事务完成时, 必须使所有的数据都保持一致状态</li><li>I 隔离性: 数据库系统提供的隔离机制, 保证事务在不收外部并发操作的影响的独立环境下运行</li><li>D 持久性: 事务一旦提交或回滚, 它对数据库的改变是永久的</li></ul><h2 id="并发事务带来了哪些问题"><a href="#并发事务带来了哪些问题" class="headerlink" title="并发事务带来了哪些问题"></a>并发事务带来了哪些问题</h2><ul><li>脏读</li><li>不可重复度</li><li>幻读: 一个事务按照条件查询, 没有对应的记录, 但是插入的时候发现记录已存在, 好像出现了幻影</li></ul><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><ul><li>多版本并发控制, 主要是通过隐藏字段(事务 id, roll_pointer), undo log 版本链和 ReadView组成的</li><li>它维护了一条数据的多个版本, 用 roll_pointer 进行连接, 形成一个 undo log 链</li><li>ReadView 快照读<ul><li>读已提交: 每次 select 都会生成快照</li><li>可重复读: 第一次 select 生成快照, 之后复用</li></ul></li></ul><p>对于一个事务视图来说, 除了自己更新总是可见的以外, 还有 3 种情况</p><ul><li>版本未提交, 不可见</li><li>版本已提交, 但是在视图创建后提交的, 不可见</li><li>版本已提交, 而且实在视图创建前提交的, 可见</li></ul><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>当同一个查询在不同的时间产生不同的结果集时, 事务中就会出现所谓的幻象, 例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>在 T1 时刻和 T2 时刻分别执行以下语句, 得到的结果集是不相同的<br>例如 T1 时刻有 5 条记录, 而 T2 时刻有 6 条记录<br>在可重复度级别下<br><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240514195706.png" alt="image.png"><br>前后两次查询结果是一样的, 没有出现幻读, 因为在可重复度级别下 select 执行的时候会创建一个快照, 在快照上读肯定没有幻读<br>但是当前读会出现幻读, 因为当前读都会查询最新版本数据, 然后再做进一步操作</p><ul><li>update</li><li>insert</li><li>delete</li><li>select … for update 都是当前读<br>我们假设 select … for update 是不会加锁, (实际上是会加锁的)<br><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240514195938.png" alt="image.png"><br>由于 select … for update 是当前读, 所以就会出现两次查询结果不一样的情况<br>所以 InnoDB 为了解决可重复读使用当前读而造成的幻读问题, 引入了间歇锁<br><img src="https://gitee.com/AWallFlower/picture/raw/master/img/20240514200205.png" alt="image.png"><br>事务 A 执行语句后就会在 id 范围为(2, +∞] 的 next-key lock(间歇锁 + 记录锁)<br>事务 B 在执行插入语句的时候, 判断插入位置被 A 加上了 next-key lock, 于是事务 B 会生成一个插入意向锁, 等待</li></ul><p>还有几种情况<br>详见小林 coding <a href="https://xiaolincoding.com/mysql/transaction/phantom.html">https://xiaolincoding.com/mysql/transaction/phantom.html</a></p><h2 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h2><ul><li>核心是 binlog 日志</li><li>从库读取主库的 binlog, 写入到从库的中继日志 Relay Log 中</li><li>从库执行中继日志的事务, 同步数据</li></ul><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><ul><li>水平分库</li><li>水平分表</li><li>垂直分库</li><li>垂直分表: 冷热数据分离, 多表互不影响(把表中某些字段分出去)</li></ul><h2 id="范围查找流程"><a href="#范围查找流程" class="headerlink" title="范围查找流程"></a>范围查找流程</h2><h3 id="有索引"><a href="#有索引" class="headerlink" title="有索引"></a>有索引</h3><p>比如找到 id &gt;&#x3D; 20 and &lt; 49的数据<br>1、加载根数据页到内存<br>2、在内存中做二分，找到对应的子页<br>3、在子页做二分，找到对应的子页<br>4、现在到了叶子节点页，在页中做二分，找到第一条满足的数据，这里是 id &#x3D; 20<br>5、一直通过叶子节点的链表指针，找到第一条不满足的为止，这里是 id &#x3D; 49<br>6、结束查找，返回数据</p><h3 id="没有索引"><a href="#没有索引" class="headerlink" title="没有索引"></a>没有索引</h3><ul><li>扫描全表</li></ul><h2 id="如何避免主从延迟"><a href="#如何避免主从延迟" class="headerlink" title="如何避免主从延迟"></a>如何避免主从延迟</h2><ul><li>强制将读请求路由到主库处理, 对于必须获取最新数据的请求, 都交给主库处理</li><li>延迟读取, 对于一些对数据比较敏感的场景, 可以在完成写请求之后, 避免立刻进行请求操作<ul><li>比如支付成功之后, 跳转到支付成功的页面, 当点击返回的时候才返回自己的账户</li></ul></li></ul><h2 id="MySQL-主键自增策略"><a href="#MySQL-主键自增策略" class="headerlink" title="MySQL 主键自增策略"></a>MySQL 主键自增策略</h2><ul><li>自增</li><li>UUID</li><li>雪花算法</li></ul><h2 id="MySQL-的索引类型"><a href="#MySQL-的索引类型" class="headerlink" title="MySQL 的索引类型"></a>MySQL 的索引类型</h2><ul><li>普通索引</li><li>唯一索引</li><li>主键索引, 一般在创建表的时候指定</li><li>联合索引</li><li>全文索引</li></ul><h2 id="间隙锁导致死锁"><a href="#间隙锁导致死锁" class="headerlink" title="间隙锁导致死锁"></a>间隙锁导致死锁</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务A</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> course <span class="hljs-keyword">where</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> course(id, user_id, <span class="hljs-keyword">no</span>) <span class="hljs-keyword">VALUE</span> (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;3&#x27;</span>);<br><br><span class="hljs-comment">-- 事务B</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> course <span class="hljs-keyword">where</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> course(id, user_id, <span class="hljs-keyword">no</span>) <span class="hljs-keyword">VALUE</span> (<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;4&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="日志有哪些"><a href="#日志有哪些" class="headerlink" title="日志有哪些"></a>日志有哪些</h2><ul><li>BinLog 日志</li><li>慢查询日志</li><li>Relay Log</li><li>Undo Log</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2024/05/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/05/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="Runnable-和-Callable-有什么区别"><a href="#Runnable-和-Callable-有什么区别" class="headerlink" title="Runnable 和 Callable 有什么区别"></a>Runnable 和 Callable 有什么区别</h2><ul><li>Runnable 的 run 方法没有返回值, Callable 的 call 方法有</li><li>Callable 的 call 方法是个泛型</li><li>Runnable 的 run 方法不能抛异常, Callable 的 call 方法可以</li></ul><h2 id="wait-和-sleep-方法有什么区别"><a href="#wait-和-sleep-方法有什么区别" class="headerlink" title="wait 和 sleep 方法有什么区别"></a>wait 和 sleep 方法有什么区别</h2><ul><li>归属不同: wait 方法是 Object 类中的, sleep 方法是 Thread 的静态方法</li><li>醒来时机不同: sleep(long) 和 wait(long) 都会在等待相应毫秒后醒来, wait 方法可以被 notify 唤醒</li><li>锁特性不同: wait 方法必须配合Synchronized 使用, sleep 无此限制<ul><li>wait 方法执行后会释放锁对象, 允许其他线程获得锁(我放弃 CPU, 你们可以用)</li><li>sleep 如果在 Synchronized 代码块中执行, 不会释放锁对象(我放弃 CPU, 你们也不能用)</li></ul></li></ul><h2 id="Synchronized-底层原理"><a href="#Synchronized-底层原理" class="headerlink" title="Synchronized 底层原理"></a>Synchronized 底层原理</h2><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><ul><li>在 1.7 版本中 ConcurrentHashMap 是用 数组 + 链表的数据结构实现的<ul><li>数组又分大数组 Segment 和小数组 HashEntry (大数组可以理解为 MySQL 的数据库, 小数组可以理解为表, 每个数组可以存储多条数据, 用链表连接)</li><li>它是基于 ReentrantLock 实现加锁和释放锁的操作, 锁的粒度为 Segment</li></ul></li><li>在 1.8 版本中用的是 数组 + 链表 + 红黑树的数据结构实现的<ul><li>用的是 CAS + volatile 或 Synchronized 方式保证线程安全</li><li>添加元素首先会判断容器是否为空, 如果为空则用 volatile + CAS 初始化</li><li>容器不为空则根据存储的元素计算位置是否为空, 为空用 CAS 设置节点</li><li>不为空则使用 Synchronized 加锁</li></ul></li></ul><h2 id="JMM-内存结构"><a href="#JMM-内存结构" class="headerlink" title="JMM 内存结构"></a>JMM 内存结构</h2><h2 id="介绍一下volatile-关键字"><a href="#介绍一下volatile-关键字" class="headerlink" title="介绍一下volatile 关键字"></a>介绍一下volatile 关键字</h2><ul><li>是用来修饰变量的</li><li>被其修饰的变量在修改后可以立即同步到主内存, 每次使用之前都是从主内存读取, 因此 volatile 可以保证可见性</li><li>volatile 可以禁止指令重排序, 被 volatile 修饰的变量操作, 会严格按照代码顺序执行</li></ul><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><ul><li>抽象队列同步器</li><li>内部维护了一个先进先出的双向队列, 队列中存储的是排队的线程</li><li>AQS 内部有一个属性 state, 相当于资源, 默认是 0, 当有一个线程成功修改 state 为 1, 则当前线程就等于获取了资源</li><li>对 state 修改的时候用 CAS 操作, 保证多个线程修改情况下的原子性</li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h2 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h2><h2 id="用线程池有什么好处"><a href="#用线程池有什么好处" class="headerlink" title="用线程池有什么好处"></a>用线程池有什么好处</h2><ul><li>不用反复创建收回线程所需要的资源</li><li>系统的响应速度更快</li><li>更加合理利用 CPU 资源</li><li>可以统一管理资源</li></ul><h2 id="线程池的创建方法"><a href="#线程池的创建方法" class="headerlink" title="线程池的创建方法"></a>线程池的创建方法</h2><ul><li>ThreadPoolExecutor 构造函数</li><li>Executors 工具类</li></ul><h2 id="什么时候使用线程池"><a href="#什么时候使用线程池" class="headerlink" title="什么时候使用线程池"></a>什么时候使用线程池</h2><ul><li>当需要频繁创建和销毁线程的时候</li><li>常量池的参数配置<ul><li>快速响应用户请求, 用户发起试试请求, 服务追求响应时间, 比如一个用户要查看商品信息, 那么响应越快越好, 所以这种场景不应该设置队列去缓存并发任务, 调高 corePoolSize 和 maxPoolSize 尽可能创造多的线程执行任务</li><li>批处理操作, 离线计算大量任务, 比如统计报表, 这种情况下, 任务量巨大不需要瞬时完成, 也就是吞吐量优先, 所以应该设置队列去缓冲并发任务</li></ul></li></ul><h2 id="notify-和-wait"><a href="#notify-和-wait" class="headerlink" title="notify 和 wait"></a>notify 和 wait</h2><ul><li>wait 和 notify 均依赖于锁, 且锁的对象必须是同一个对象, 否则无法执行唤醒</li><li>notify 唤醒是随机唤醒一个线程, 唤醒的范为是同一锁对象, 所有 wait 的线程</li></ul><p>notify 同一依赖于锁, 必须在同步快中执行, 执行之后会立刻释放锁吗?</p><ul><li>notify 在执行后不会立即唤醒, 而是等到 notify 同步块执行完之后才会去执行唤醒</li></ul><h2 id="wait-notify-和-await-signal-关系"><a href="#wait-notify-和-await-signal-关系" class="headerlink" title="wait&#x2F;notify 和 await&#x2F;signal 关系"></a>wait&#x2F;notify 和 await&#x2F;signal 关系</h2><ul><li>wait&#x2F;notify <ul><li>基于 Synchronized 实现的</li><li>无法控制唤醒谁, 随机唤醒</li></ul></li><li>await&#x2F;signal <ul><li>基于 Lock 实现的</li><li>使用 Condition 对象可以细粒度低控制线程的等待和唤醒</li></ul></li></ul><h2 id="Executors-工具类提供的四个线程池子"><a href="#Executors-工具类提供的四个线程池子" class="headerlink" title="Executors 工具类提供的四个线程池子"></a>Executors 工具类提供的四个线程池子</h2><ul><li><code>newSingleThreadExecutor()</code> 用于需要保证任务按顺序执行的场景<ul><li>corePoolSize: 1</li><li>maximumPoolSize: 1</li><li>阻塞队列: LinkedBlockingQueue 大小是 Integer.MAX_VALUE</li></ul></li><li><code>newFixedThreadPool(int nThreads)</code> 用于负载稳定、任务量恒定的场景<ul><li>corePoolSize: nThreads</li><li>maximumPoolSize: nThreads</li><li>阻塞队列: LinkedBlockingQueue 大小是 Integer.MAX_VALUE</li></ul></li><li><code>newCachedThreadPool()</code> 适用于执行大量短期异步任务的场景，能高效地利用系统资源<ul><li>corePoolSize: 0</li><li>maximumPoolSize: Integer.MAX_VALUE</li><li>阻塞队列: 大小为 0</li></ul></li><li><code>ScheduledThreadPoolExecutor(int corePoolSize)</code> 用于需要定时或周期性执行任务的场景<ul><li>corePoolSize: 0</li><li>maximumPoolSize: Integer.MAX_VALUE</li><li>阻塞队列: 大小无界, 按照延迟的时间长短对任务进行排序</li></ul></li></ul><h2 id="shutdown-和-shutdownNow"><a href="#shutdown-和-shutdownNow" class="headerlink" title="shutdown() 和 shutdownNow()"></a>shutdown() 和 shutdownNow()</h2><ul><li>shutdown(): 关闭线程池, 线程池的状态变为 SHUTDOWN, 线程池不再接受新任务, 但是队列里的任务得执行完毕</li><li>shutdownNow(): 关闭线程池, 线程池的状态变为 STOP, 线程池会终止当前正在运行的任务, 并停止处理排队的任务并返回正在等待执行的 List</li></ul><h2 id="isTerminated-和-isShutdown"><a href="#isTerminated-和-isShutdown" class="headerlink" title="isTerminated() 和 isShutdown()"></a>isTerminated() 和 isShutdown()</h2><ul><li>isShutdown(): 当调用 shutdown() 方法后返回 true</li><li>isTerminated: 当调用 shutdown() 方法后, 并执行完所有提交的任务后返回 true</li></ul><h2 id="如何正确使用线程池"><a href="#如何正确使用线程池" class="headerlink" title="如何正确使用线程池"></a>如何正确使用线程池</h2><ul><li>正确声明线程池, 用 ThreadExecutorPool 构造函数声明, 而不是 Executors 工具类(会有 OOM 的风险)</li><li>监测线程池运行状态, SpringBoot 的 Actuator 组件</li><li>建议不同业务使用不同的线程池</li><li>给线程池命名</li><li>别忘记关闭线程池</li><li>线程池尽量不要放耗时任务, 耗时任务用消息队列异步执行</li></ul><h2 id="动态调整线程池大小-美团"><a href="#动态调整线程池大小-美团" class="headerlink" title="动态调整线程池大小(美团)"></a>动态调整线程池大小(美团)</h2><ul><li>用 setCorePoolSize 调整核心线程池大小</li><li>用 setMaximumPoolSize 调整最大线程池大小</li><li>重写 LinkedBlockingQueue, 把里面的 capacity 字段的 final关键字去掉, 变为可变的</li></ul><h2 id="动态调整线程池大小-Nacos"><a href="#动态调整线程池大小-Nacos" class="headerlink" title="动态调整线程池大小(Nacos)"></a>动态调整线程池大小(Nacos)</h2><ul><li><code>@RefreshScope</code> 支持 Nacos 动态刷新</li><li><code>@Value(&quot;$&#123;max.size&#125;&quot;</code> 读取在 Nacos 配置的具体信息</li><li>配置监听, Nacos 配置变更时实时修改线程池配置</li></ul><h2 id="线程池中线程异常后-销毁还是复用"><a href="#线程池中线程异常后-销毁还是复用" class="headerlink" title="线程池中线程异常后, 销毁还是复用?"></a>线程池中线程异常后, 销毁还是复用?</h2><ul><li>使用 execute() 提交任务<ul><li>如果异常没有在任务内捕获, 那么该异常会导致当前线程终止, 控制台打印日志</li><li>线程池会检测到这种异常终止, 并创建一个新的线程来替换它, 从而保证配置的线程数不变</li></ul></li><li>使用 submit() 提交任务<ul><li>如果在执行中发生异常, 会封装在 submit() 返回的 <code>Future</code> 对象中</li><li>当调用 <code>Future.get()</code> 方法可以捕获到一个 <code>ExecutionException</code> </li><li>线程不会因异常终止, 会继续存在线程池中</li></ul></li></ul><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><ul><li>是用来做多个任务的编排的, 规定任务前后执行顺序</li><li>Future 不支持异步任务的编排, 获取计算结果的 <code>get()</code> 方法为阻塞调用</li></ul><h2 id="Java-不同锁的实现和使用场景"><a href="#Java-不同锁的实现和使用场景" class="headerlink" title="Java 不同锁的实现和使用场景"></a>Java 不同锁的实现和使用场景</h2><ul><li><code>synchronized</code> 关键字<ul><li>可重入锁</li><li>非公平锁</li></ul></li><li><code>ReentrantLock</code><ul><li>可重入锁</li><li>AQS 队列</li><li>可以实现公平锁</li></ul></li><li><code>ReadWrite Lock</code> 读写锁<ul><li>读锁是共享锁, 读读不互斥, 获取到读锁的时候, 无法获取写锁</li><li>写锁是独占锁, 加上写锁的时候别的线程读写都不行</li></ul></li></ul><h2 id="CountDownLatch-类-倒计时器"><a href="#CountDownLatch-类-倒计时器" class="headerlink" title="CountDownLatch 类(倒计时器)"></a>CountDownLatch 类(倒计时器)</h2><ul><li>CountDownLatch 允许 count 个线程阻塞在一个地方, 直至所有线程的任务都执行完毕</li><li>典型用法<ul><li>某一个线程在开始运行前等待 n 个线程执行完毕: 将 CountDownLatch 的计数器初始化为 n, 每当一个任务线程执行完毕, 就将计数器 -1, 当计数器的值变为 0 时, 在 CountDownLatch 上 await() 的线程就被唤醒<ul><li>典型应用场景就是启动一个服务时, 主线程需要等待多个组件加载完成, 之后再继续执行</li></ul></li><li>实现多个线程开始执行任务的最大并发性: 强调的是多个线程在某一时刻同时开始执行, 类似于赛跑, 将多个线程放到起点, 同时开跑, 初始化一个共享的 CountDownLatch 对象, 将其计数器初始化为 1, 多个线程在开始执行任务前首先 <code>countdownLathch.await()</code> 当主线程调用 countDown() 时, 计数器变为 0, 多个线程被同时唤醒</li></ul></li></ul><h2 id="如何预防死锁"><a href="#如何预防死锁" class="headerlink" title="如何预防死锁"></a>如何预防死锁</h2><ul><li>破坏请求与保持条件: 一次性申请所有资源</li><li>破坏不可剥夺条件: 占用部分资源的线程去申请其他资源时, 如果申请不到, 主动释放他所占用的资源</li><li>破坏循环等待条件: 按照顺序申请资源, 释放资源反序释放</li></ul><h2 id="java-多线程通信"><a href="#java-多线程通信" class="headerlink" title="java 多线程通信"></a>java 多线程通信</h2><ul><li>锁</li><li><code>wait/notify</code></li><li><code>volatile</code> </li><li>管道</li><li><code>join</code></li><li><code>ThreadLocal</code></li></ul><h2 id="如何检测死锁"><a href="#如何检测死锁" class="headerlink" title="如何检测死锁"></a>如何检测死锁</h2><ul><li><code>jstack</code> 命令可以查看 JVM 线程栈和堆内存的情况, 如果有死锁, 通常会输出 <code>Found one Java-level deadlock</code> 字样</li><li>实际项目可以用 <code>top</code> 查看 CPU 占用情况, 出现死锁会导致 CPU 内存占用过高</li></ul><h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><ul><li>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
